[
["index.html", "R Markdown Cookbook Preface", " R Markdown Cookbook Yihui Xie 2020-02-17 Preface This book is in a very early stage of development. If you have any suggestions on what should be included within this book, please get in touch via GitHub. R Markdown is a powerful tool for combining analysis and reporting into the same document. Since the development of the rmarkdown package (Allaire et al. 2020), it has grown to become a diverse ecosystem of code, and reports, books and websites can all easily be generated directly from R code. There is a wealth of guidance which has grown over the past few years, and the book R Markdown: The Definitive Guide (Xie, Allaire, and Grolemund 2018) provides an overview of all that can be done with R Markdown. However, as noted by Yihui, it was commented by the publisher that it would be beneficial to provide more practical examples of the use of R Markdown. And so, the idea of this book was born. To fill the gap for official documentation, users often seek for help on StackOverflow. At the time of writing, there were almost 4,000 different questions with the r-markdown tag. However, the use of the website is relatively difficult if you do not have a specific problem you are trying to search for, and therefore it is hard to be able to tell what is possible with R Markdown unless you have the insight to search for a specific question. This book aims to draw together much existing literature from StackOverflow and other details hidden across the internet to provide up-to-date solutions for everyday queries that users commonly face. This book is designed to provide a range of examples of how to extend the functionality of your R Markdown documents. As a cookbook, this guide is recommended to new or intermediate R Markdown users who are looking for practical examples of how R Markdown documents can be effectively updated. References "],
["how-to-read-this-book.html", "How to read this book", " How to read this book The book is designed to highlight the many ways in which your R Markdown documents can be customized. Users are encouraged to try using the concepts within their own documents. The code detailed in the book should be sufficient, but the full source code and examples are provided on GitHub. It is recommended that readers have a basic understanding of R Markdown. Chapter 2 of R Markdown: The Definitive Guide (Xie, Allaire, and Grolemund 2018) provides an overview of the basics of R Markdown and is recommended background reading for any new users of R Markdown. It should be noted that this guide does not intend to provide a full technical reference for R Markdown, and there is already extensive literature available on these topics. This book aims to supplement, not replace, this existing literature, and it is therefore recommended that readers explore the following books if they seek further information: R Markdown: The Definitive guide (Xie, Allaire, and Grolemund 2018): provides an overview of the R Markdown package and the wide range of ways it can be used. Dynamic documents and knitr: provides more detailed technical guidance on the inner workings of rmarkdown and knitr (Xie 2020b). Authoring books with bookdown (Xie 2016): a short book which provides details on the bookdown package (Xie 2020a), which is designed to simplify the creation of long-format documents in R Markdown. blogdown: Creating Websites with R Markdown [blogdown2017]: provides details of the blogdown package (Xie 2019a) package. Where relevant, this book provides references to these existing resources. References "],
["structure-of-the-book.html", "Structure of the book", " Structure of the book The book is broken down into small “recipes” which aim to demonstrate a single concept at a time. Chapter content to be finalised once recipes created. "],
["software-info.html", "Software information and conventions", " Software information and conventions The R session information used when compiling this book is as follows: xfun::session_info(c( &#39;bookdown&#39;, &#39;knitr&#39;, &#39;rmarkdown&#39;), dependencies = FALSE) ## R version 3.6.2 (2017-01-27) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 16.04.6 LTS ## ## Locale: ## LC_CTYPE=en_US.UTF-8 ## LC_NUMERIC=C ## LC_TIME=en_US.UTF-8 ## LC_COLLATE=en_US.UTF-8 ## LC_MONETARY=en_US.UTF-8 ## LC_MESSAGES=en_US.UTF-8 ## LC_PAPER=en_US.UTF-8 ## LC_NAME=C ## LC_ADDRESS=C ## LC_TELEPHONE=C ## LC_MEASUREMENT=en_US.UTF-8 ## LC_IDENTIFICATION=C ## ## Package version: ## bookdown_0.17 knitr_1.28.2 rmarkdown_2.1 ## ## Pandoc version: 2.3.1 We do not add prompts (&gt; and +) to R source code in this book, and we comment out the text output with two hashes ## by default, as you can see from the R session information above. This is for your convenience when you want to copy and run the code (the text output will be ignored since it is commented out). Package names are in bold text (e.g., rmarkdown), and inline code and filenames are formatted in a typewriter font (e.g., knitr::knit('foo.Rmd')). Function names are followed by parentheses (e.g., blogdown::serve_site()). The double-colon operator :: means accessing an object from a package. “Rmd” is the filename extension of R Markdown files, and also an abbreviation of R Markdown in this book. "],
["acknowledgements.html", "Acknowledgements", " Acknowledgements "],
["author.html", "About the Authors", " About the Authors "],
["installation.html", "Chapter 1 Installation", " Chapter 1 Installation To use R Markdown, you have to install R (R Core Team 2017) and the R package rmarkdown (Allaire et al. 2020). We also recommend that you install the RStudio IDE (https://www.rstudio.com). RStudio is not required, but it will make it easier for an average user to work with R Markdown because of the editor support. If choose not to use the RStudio IDE, you will need a separate installation of Pandoc (https://pandoc.org). # install the rmarkdown package from CRAN in R install.packages(&quot;rmarkdown&quot;) # or install from GitHub if you want to test the # development version if (!requireNamespace(&quot;remotes&quot;)) install.packages(&quot;remotes&quot;) remotes::install_github(&quot;rstudio/rmarkdown&quot;) References "],
["install-latex.html", "1.1 Install LaTeX for PDF reports", " 1.1 Install LaTeX for PDF reports If you would like to create PDF documents from R Markdown, you will need to have a LaTeX distribution installed. Although there are several traditional options including MiKTeX, MacTeX, and TeX Live, we recommend that R Markdown users install TinyTeX. TinyTeX is a custom LaTeX distribution based on TeX Live that is small in size (150Mb on macOS/Linux and 220Mb on Windows when installed) but functions well in most cases, especially for R users. Installing or running TinyTeX does not require sysadmin privileges. You can install TinyTeX with the R package tinytex (Xie 2020c): tinytex::install_tinytex() # to uninstall TinyTeX, run tinytex::uninstall_tinytex() Please note that “tinytex” refers to the R package, and “TinyTeX” refers to the LaTeX distribution. There are two advantages of using TinyTeX: TinyTeX is lightweight (compared to other LaTeX distributions), cross-platform, and portable. For example, you can store a copy of TinyTeX on your USB drive or other portable devices, and use it on other computers with the same operating system. When R Markdown is converted to PDF, Pandoc converts Markdown to an intermediate LaTeX document first. The R package tinytex has provided helper functions to compile LaTeX documents to PDF (the main function is tinytex::latexmk()). If you use TinyTeX and certain LaTeX packages are required but not installed, tinytex will try to automatically install them for you. It will also try to compile the LaTeX file for a sufficient number of times to make sure all cross-references are resolved. If you are interested in the technical details, you may check out the article Xie (2019b) and the FAQ page at https://yihui.org/tinytex/faq/. References "],
["basics.html", "Chapter 2 Basics", " Chapter 2 Basics This book by no means intends to be a comprehensive guide to R Markdown. However, it is important to provide an overview of the R Markdown ecosystem before we drill down to specific examples and recipes. This chapter aims to provide the basic concepts required for the book. For those seeking the background, we recommend that readers refer to the R Markdown definitive guide (Xie, Allaire, and Grolemund 2018), which provides a comprehensive overview of the R Markdown components. References "],
["r-markdown-components.html", "2.1 R Markdown components", " 2.1 R Markdown components R Markdown combines several different processes together to create documents, and one of the main sources of confusion from R Markdown is how all the components work together. Fortunately, as a user, it is not essential to understand all the inner workings of these processes to be able to create documents. However, as a user who may be seeking to alter the behavior of a document, it is important to understand which component is responsible for what. This makes it a lot easier to seek help as you can target your searches on the correct area. The basic workflow structure for an R Markdown document is shown in Figure 2.1, highlighting the steps (arrows) and the intermediate files that are created before producing the output. The whole process is implemented via the function rmarkdown::render(). Each stage is explained in further detail below. FIGURE 2.1: A diagram illustrating how an R Markdown document is converted to the final output document. The .Rmd document is the original format of the document. It contains a combination of YAML (metadata), text (narratives), and code chunks. First, the knit() function in knitr is used to execute all code embedded within the .Rmd file, and prepare the code output to be displayed within the output document. All these results are converted into the correct markup language to be contained within the temporary .md file. Then the .md file is processed by Pandoc, a multipurpose tool designed to convert files from one markup language to another. It takes any parameters specified within the YAML frontmatter of the document (e.g., title, author, and date) to convert the document to the output format specified in the output parameter (such as html_document for HTML output). If the output format is PDF, there is an additional layer of processing, as Pandoc will convert the intermediate .md file into an intermediate .tex file. This file is then processed by LaTeX to form the final PDF document. As we mentioned in Section 1.1, the rmarkdown package calls the latexmk() function in the tinytex package (Xie 2020c), which in turn calls LaTeX to compile .tex to .pdf. In short, rmarkdown::render() = knitr::knit() + Pandoc (+ LaTeX for PDF output only). Robin Linacre has written a nice summary of the relationship between R Markdown, knitr, and Pandoc at https://stackoverflow.com/q/40563479/559676, which contains more technical details than the above overview. References "],
["spin.html", "2.2 Render an R script to a report", " 2.2 Render an R script to a report Even if you are a long-time R Markdown user, you may have missed another possibility. Dean Attali called it “knitr’s best hidden gem”. That is, you can render a pure R script to a report directly. If you use the RStudio IDE, the keyboard shortcut to render R scripts is the same as when you knit Rmd documents (Ctrl / Cmd + Shift + K). When rendering an R script to a report, the function knitr::spin() is called to convert the R script to an Rmd file first. This function is what Dean Attali called knitr’s best hidden gem. You will see all text and graphical output in the report. If you want granular control over the elements in the report, below are a few syntax rules to help you: Roxygen comments will be treated as normal text. A roxygen comment is an R comment that starts with #'. This can help you write narratives in your report. You can use any Markdown syntax in the comments. A comment starting with #+ is treated as the knitr chunk header. For example, knitr::spin() will translate the comment #+ label, fig.width=5 to the chunk header ```{r label, fig.width=5} in R Markdown. R code of the form {{ code }} is translated to an inline R expression in R Markdown. Please note that {{ code }} must be on its own line. The YAML frontmatter can be written in the beginning of the R script in roxygen comments, too. Any text between /* and */ will be ignored (i.e., they are treated as true comments). Below is a full example illustrating the above rules: #&#39; --- #&#39; title: &quot;A report generted from a pure R script&quot; #&#39; output: #&#39; pdf_document: #&#39; keep_tex: true #&#39; --- #&#39; #&#39; This is a report generated by `knitr::spin()`. #&#39; #&#39; Let&#39;s try some **knitr** options: #+ echo=FALSE, fig.width=7 # This is a normal R comment. plot(cars) #&#39; Now write an inline value. We know the value of $\\pi$ is {{ pi }} #&#39; . #&#39; #&#39; Finally please note that all roxygen comments are #&#39; optional. You do not need chunk options, either, #&#39; unless you want more control over the output #&#39; elements such as the size of plots. # /* Write comments between /* and */ like C comments: Sys.sleep(60) # */ When this script is rendered to a report, knitr::spin() will convert it to R Markdown: --- title: &quot;A report generted from a pure R script&quot; output: pdf_document: keep_tex: true --- This is a report generated by `knitr::spin()`. Let&#39;s try some **knitr** options: ```{r echo=FALSE, fig.width=7} # This is a normal R comment. plot(cars) ``` Now write an inline value. We know the value of $\\pi$ is ``r pi `` . Finally please note that all roxygen comments are optional. You do not need chunk options, either, unless you want more control over the output elements such as the size of plots. This method of generating reports can be particularly useful when you primarily work with R scripts and do not need a lot of narratives. If the proportion of text is substantial in your report, R Markdown may be a better choice, because you do not need to put all text in roxygen comments. "],
["purl.html", "2.3 Convert R Markdown to R script", " 2.3 Convert R Markdown to R script When you want to extract all R code from an R Markdown document, you can call the function knitr::purl(). Below is a simple Rmd example with the filename purl.Rmd: --- title: Use `purl()` to extract R code --- The function `knitr::purl()` extracts R code chunks from a **knitr** document and save the code to an R script. Below is a simple chunk: ```{r, simple, echo=TRUE} 1 + 1 ``` Inline R expressions like `r 2 * pi` are ignored by default. If you do not want certain code chunks to be extracted, you can set the chunk option `purl = FALSE`, e.g., ```{r, ignored, purl=FALSE} x = rnorm(1000) ``` If we call knitr::purl(&quot;purl.Rmd&quot;), it generates the following R script (with the filename purl.R by default): ## ---- simple, echo=TRUE------------------------------ 1 + 1 The above R script contains the chunk options in a comment. If you want pure R code, you may call knitr::purl() with the argument documentation = 0, which will generate the R script below: 1 + 1 If you want to retain all the text, you may use the argument documentation = 2, which generates the R script below: #&#39; --- #&#39; title: Use `purl()` to extract R code #&#39; --- #&#39; #&#39; The function `knitr::purl()` extracts R code chunks from #&#39; a **knitr** document and save the code to an R script. #&#39; #&#39; Below is a simple chunk: #&#39; ## ---- simple, echo=TRUE------------------------------ 1 + 1 #&#39; #&#39; Inline R expressions like `r 2 * pi` are ignored by default. #&#39; #&#39; If you do not want certain code chunks to be extracted, #&#39; you can set the chunk option `purl = FALSE`, e.g., #&#39; Note that code chunks with the option purl = FALSE will be excluded in the R script. Inline R expressions are ignored by default. If you want to include them in the R script, you need to set the global R option options(knitr.purl.inline = TRUE) before calling knitr::purl(). "],
["document-elements.html", "Chapter 3 Document Elements", " Chapter 3 Document Elements In this chapter, we introduce some tips and tricks that can be used to customize the content of R Markdown documents. "],
["bibliography.html", "3.1 Bibliographies and citations", " 3.1 Bibliographies and citations For an overview of including bibliographies in your output document, you may see Section 2.8 of Xie (2016). The basic usage requires us to specify a bibliography file using the bibliography metadata field in YAML. For example: --- output: html_document bibliography: references.bib --- where the BibTeX database is a plain-text file with the *.bib extension that consists of bibliography entries like this: @Manual{R-base, title = {R: A Language and Environment for Statistical Computing}, author = {{R Core Team}}, organization = {R Foundation for Statistical Computing}, address = {Vienna, Austria}, year = {2019}, url = {https://www.R-project.org}, } Items can be cited directly within the documentation using the syntax @key where key is the citation key in the first line of the entry, e.g., @R-base. To put citations in parentheses, use [@key]. To cite multiple entries, separate the keys by semicolons, e.g., [@key-1; @key-2; @key-3]. 3.1.1 Changing citation style By default, Pandoc will use a Chicago author-date format for citations and references. To use another style, you will need to specify a CSL (Citation Style Language) style file in the csl metadata field, e.g., --- output: html_document bibliography: references.bib csl: biomed-central.csl --- To find your required formats, we recommend using the Zotero website, which makes it easy to search for and download your desired style. CSL files can be tweaked to meet custom formatting requirements. For example, we can change the number of authors required before “et. al” is used to abbreviate them. This can be simplified through the use of visual editors such as the one available at http://editor.citationstyles.org. 3.1.2 Add an item to bibliography without using it By default, the bibliography will only display items that are directly referenced in the document. If you want to include items in the bibliography without actually citing them in the body text, you can define a dummy nocite metadata field and put the citations there. --- nocite: | @item1, @item2 --- 3.1.3 Add all items to bibliography If we do not wish to explicitly state all of the items within the bibliography but would still like to show them in our references, we can use the following syntax: --- nocite: &#39;@*&#39; --- This will force all items to be displayed in the bibliography. 3.1.4 Include appendix after bibliography By default, the bibliography appears at the very end of the document. However, there can be cases in which we want to place additional text after the references, most typically if we wish to include appendices in the document. We can force the position of the references by using &lt;div id=&quot;refs&quot;&gt;&lt;/div&gt;, as shown below: # References &lt;div id=&quot;refs&quot;&gt;&lt;/div&gt; # Appendix We can improve this further by using the bookdown package, which offers a special header for the appendix as shown with the syntax below: # References &lt;div id=&quot;refs&quot;&gt;&lt;/div&gt; # (APPENDIX) Appendix {-} # Appendix A # Appendix B The numbering style of appendices will be automatically changed in LaTeX/PDF and HTML output (usually in the form A, A.1, A.2, B, B.1, and so on). References "],
["write-bib.html", "3.2 Generate R package citations", " 3.2 Generate R package citations To cite an R package, you can use the function citation() from base R. If you want to generate a citation entry for BibTeX, you can pass the returned object of citation() to toBibtex(), e.g., toBibtex(citation(&quot;xaringan&quot;)) @Manual{, title = {xaringan: Presentation Ninja}, author = {Yihui Xie}, year = {2019}, note = {R package version 0.13}, url = {https://CRAN.R-project.org/package=xaringan}, } To use citation entries generated from toBibtex(), you have to copy the output to a .bib file, and add citation keys (e.g., @Manual{R-xaringan,). This can be automated via the function knitr::write_bib(), which generates citation entries to a file and adds keys automatically, e.g., knitr::write_bib(c(.packages(), &quot;bookdown&quot;), &quot;packages.bib&quot;) The first argument should be a character vector of package names, and the second argument is the path to the .bib file. In the above example, .packages() returns the names of all packages loaded in the current R session. This makes sure all packages being used will have their citation entries written to the .bib file. When any of these packages are updated (e.g., the author, title, or year, or version of a package is changed), write_bib() can automatically update the .bib file. There are two possible types of citation entries. One type is those generated from the package’s DESCRIPTION file, and the other type is generated from the package’s CITATION file if provided. For the former type, the citation keys are of the form R-pkgname, where pkgname is the package name (e.g., R-knitr). For the latter type, the keys are created by concatenating the package name and the publication year (e.g., knitr2015). If there are multiple entries in the same year, a letter suffix will be added, e.g., knitr2015a and knitr2015b. The former type is often used to cite the package itself (i.e., the software), and the latter type often consists of publications related to the package, such as journal papers or books. knitr::write_bib(c(&quot;knitr&quot;, &quot;rmarkdown&quot;), width = 60) @Manual{R-knitr, title = {knitr: A General-Purpose Package for Dynamic Report Generation in R}, author = {Yihui Xie}, year = {2020}, note = {R package version 1.28.2}, url = {https://yihui.org/knitr/}, } @Manual{R-rmarkdown, title = {rmarkdown: Dynamic Documents for R}, author = {JJ Allaire and Yihui Xie and Jonathan McPherson and Javier Luraschi and Kevin Ushey and Aron Atkins and Hadley Wickham and Joe Cheng and Winston Chang and Richard Iannone}, year = {2020}, note = {R package version 2.1}, url = {https://CRAN.R-project.org/package=rmarkdown}, } @Book{knitr2015, title = {Dynamic Documents with {R} and knitr}, author = {Yihui Xie}, publisher = {Chapman and Hall/CRC}, address = {Boca Raton, Florida}, year = {2015}, edition = {2nd}, note = {ISBN 978-1498716963}, url = {https://yihui.org/knitr/}, } @InCollection{knitr2014, booktitle = {Implementing Reproducible Computational Research}, editor = {Victoria Stodden and Friedrich Leisch and Roger D. Peng}, title = {knitr: A Comprehensive Tool for Reproducible Research in {R}}, author = {Yihui Xie}, publisher = {Chapman and Hall/CRC}, year = {2014}, note = {ISBN 978-1466561595}, url = {http://www.crcpress.com/product/isbn/9781466561595}, } @Book{rmarkdown2018, title = {R Markdown: The Definitive Guide}, author = {Yihui Xie and J.J. Allaire and Garrett Grolemund}, publisher = {Chapman and Hall/CRC}, address = {Boca Raton, Florida}, year = {2018}, note = {ISBN 9781138359338}, url = {https://bookdown.org/yihui/rmarkdown}, } Without the file path argument, knitr::write_bib() writes the citation entries to the R console, as you can see from the above example. Note that write_bib() is designed to overwrite the existing bibliography file. If you want to manually add any other entries to the bibliography, it is recommended that you create a second .bib file and refer to it in the YAML field bibliography, e.g., --- bibliography: [packages.bib. references.bib] --- ```{r, include=FALSE} knitr::write_bib(file = &#39;packages.bib&#39;) ``` In the above example, packages.bib is automatically generated, and you should not manually change it. All other citation entries can be manually written to references.bib. "],
["cross-ref.html", "3.3 Cross-referencing within documents", " 3.3 Cross-referencing within documents Cross-referencing is a useful way of directing your readers through your document, and can be automatically done within R Markdown. While this has been explained in Chapter 2 from the bookdown book, we want to present a brief summary below. To use cross-references, you have to: Use a bookdown output format: cross-referencing is not provided directly within the base rmarkdown package, but is provided as an extension in bookdown. We must therefore use an output format from bookdown (e.g., html_document2, pdf_document2, and word_document2, etc.) in the YAML output field. A caption to your figure (or table): figures without a caption will be included directly as images and will therefore not be a numbered figure. A labeled code chunk: this provides the identifier for referencing the figure generated by the chunk. After these conditions are met, we can make cross-references within the text using the syntax \\@ref(type:label), where label is the chunk label and type is the environment being referenced (e.g. tab, fig, or eqn). An example is provided below: --- title: Cross-referencing figures, tables, and equations author: Generated by bookdown output: bookdown::html_document2: default bookdown::pdf_document2: default --- See Figure \\@ref(fig:cars-plot). ```{r cars-plot, fig.cap=&quot;The cars data.&quot;, echo=FALSE} par(mar = c(4, 4, .2, .1)) plot(cars) # a scatterplot ``` Also see Equation \\@ref(eq:mean). \\begin{equation} \\bar{X} = \\frac{\\sum_{i=1}^n X_i}{n} (\\#eq:mean) \\end{equation} And see Table \\@ref(tab:mtcars). ```{r mtcars, echo=FALSE} knitr::kable(mtcars[1:5, 1:5], caption = &quot;The mtcars data.&quot;) ``` The output of this document is shown in Figure 3.1. FIGURE 3.1: Example of cross-referencing within an R Markdown document. You can also cross-reference equations, theorems, and section headers. These types of references are explained further in Section 2.2 and Section 2.6 of the bookdown book. "],
["update-date.html", "3.4 Update the date automatically", " 3.4 Update the date automatically If you want the date on which the Rmd document is compiled to be reflected in the output report, you can add an inline R expression to the date field in YAML, and use the Sys.Date() or Sys.time() function to obtain the current date, e.g., date: &quot;`r Sys.Date()`&quot; You may want to specify the desired date or date-time format to make it more human-readable, e.g., date: &quot;`r format(Sys.time(), &#39;%d %B, %Y&#39;)`&quot; This will generate the date dynamically each time you knit your document, e.g., 17 February, 2020. If you wish to customize the format of the dates, you can alter the time format by providing your own format string. Here are some examples: %B %Y: February 2020 %d/%m/%y: 17/02/20 %a/%d/%b: Mon 17 Feb A full table of POSIXct formats is shown in Table 3.1. TABLE 3.1: Date and time formats in R. Code Meaning Code Meaning %a Abbreviated weekday %A Full weekday %b Abbreviated month %B Full month %c Locale-specific date and time %d Decimal date %H Decimal hours (24 hour) %I Decimal hours (12 hour) %j Decimal day of the year %m Decimal month %M Decimal minute %p Locale-specific AM/PM %S Decimal second %U Decimal week of the year (starting on Sunday) %w Decimal Weekday (0=Sunday) %W Decimal week of the year (starting on Monday) %x Locale-specific Date %X Locale-specific Time %y 2-digit year %Y 4-digit year %z Offset from GMT %Z Time zone (character) As a final note, you may also want to include some explanatory text along with the date. You can add any text such as “Last compiled on” before the R code as follows: date: &quot;Last compiled on `r format(Sys.time(), &#39;%d %B, %Y&#39;)`&quot; "],
["multiple-authors.html", "3.5 Multiple authors in a document", " 3.5 Multiple authors in a document We can add multiple authors to an R Markdown document within the YAML frontmatter in a number of ways. If we simply want to list them on the same line, we can provide a single string to the document, e.g., --- title: &quot;Untitled&quot; author: &quot;John Doe, Jane Doe&quot; --- Alternatively, if we wish for each entry to be on its own line, we can provide a list of entries to the YAML field. This can be useful if you wish to include further information about each author such as an Email address or institution, e.g., --- author: - John Doe, Institution One - Jane Doe, Institution Two --- We can make use of the Markdown syntax ^[] to add additional information as a footnote to the document. This may be more useful if you have extended information that you wish to include for each author, such as providing a contact Email and address. The exact behavior will depend on the output format: --- author: - John Doe^[Institution One, john@example.org] - Jane Doe^[Institution Two, jane@example.org] --- Certain R Markdown templates will allow you to specify additional parameters directly within the YAML. For example, the Distill output format allows url, affiliation, and affiliation_url to be specified. After you install the distill package: install.packages(&quot;distill&quot;) You can use the Distill format with detailed author information, e.g., --- title: &quot;Distill for R Markdown&quot; author: - name: &quot;JJ Allaire&quot; url: https://github.com/jjallaire affiliation: RStudio affiliation_url: https://www.rstudio.com output: distill::distill_article --- "],
["figure-number.html", "3.6 Numbered figure captions", " 3.6 Numbered figure captions We can use bookdown output formats to add figure numbers to their captions. Below is an example: --- output: bookdown::html_document2 --- ```{r cars, fig.cap = &quot;An amazing plot&quot;} plot(cars) ``` ```{r mtcars, fig.cap = &quot;Another amazing plot&quot;} plot(mpg ~ hp, mtcars) ``` Section 3.3 demonstrates how this works for other elements such as tables and equations, and how to cross-reference the numbered elements within the text. Besides html_document2, there are several other similar functions for other output formats, such as pdf_document2 and word_document2. You can add this feature to R Markdown output formats outside bookdown, too. The key is to use those formats as the “base formats” of bookdown output formats. For example, to number and cross-reference figures in the rticles::jss_article format, you can use: output: bookdown::pdf_book: base_format: rticles::jss_article Please read the help pages of the bookdown output format functions to see if they have the base_format argument (e.g., ?bookdown::html_document2). "],
["combine-words.html", "3.7 Combine words into a comma-separated phrase", " 3.7 Combine words into a comma-separated phrase When you want to output a character vector for humans to read (e.g., x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)), you probably do not want something like [1] &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;, which is the normal way to print a vector in R. Instead, you may want a character string “apple, banana, and cherry”. There is a base R function paste() that you can use to concatenate a character vector into a single string, e.g., paste(x, collapse = ', '), and the output will be &quot;apple, banana, cherry&quot;. The problems are (1) the conjunction “and” is missing, and (2) when the vector only contains two elements, we should not use commas (e.g., the output should be &quot;apple and banana&quot; instead of &quot;apple, banana&quot;). The function knitr::combine_words() can be used to concatenate words into a phrase regardless of the length of the character vector. Basically, for a single word, it will just return this word; for two words A and B, it return &quot;A and B&quot;; for three or more words, it returns &quot;A, B, C, ..., Y, and Z&quot;. The function also has a few arguments that can customize the output. For example, if you want to output the words in pairs of backticks, you may use knitr::combine_words(x, before = '`'). v &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) knitr::combine_words(v) ## apple, banana, and cherry knitr::combine_words(v, before = &quot;`&quot;, after = &quot;&#39;&quot;) ## `apple&#39;, `banana&#39;, and `cherry&#39; knitr::combine_words(v, and = &quot;&quot;) ## apple, banana, cherry knitr::combine_words(v, sep = &quot; / &quot;, and = &quot;&quot;) ## apple / banana / cherry knitr::combine_words(v[1]) # a single word ## apple knitr::combine_words(v[1:2]) # two words ## apple and banana knitr::combine_words(LETTERS[1:5]) ## A, B, C, D, and E This function can be particularly handy when it is used in an inline R expression, e.g., This morning we had `r knitr::combine_words(v)` for breakfast. "],
["linebreaks.html", "3.8 Preserve a large number of linebreaks", " 3.8 Preserve a large number of linebreaks Markdown users may be surprised to realize that whitespaces (including linebreaks) are usually meaningless unless they are used in a verbatim environment (code blocks). Two or more spaces are the same as one space, and a linebreak is the same as a space. If you have used LaTeX or HTML before, you may not be surprised because the rule is the same in these languages. In Markdown, we often use a blank line to separate elements such as paragraphs. To break a line without introducing a new paragraph, you have to use two trailing spaces. Sometimes you may want to break the lines for many times, especially when you write or quote poems or lyrics. Adding two spaces after each line manually is a tedious task. The function blogdown:::quote_poem() can do this task automatically, e.g., blogdown:::quote_poem(c(&quot;This line&quot;, &quot;should be&quot;, &quot;broken.&quot;)) ## [1] &quot;&gt; This line \\nshould be \\nbroken.&quot; If you use the RStudio IDE, you can select the text in which you want to preserve the linebreaks, and apply the addin “Quote Poem”. For example, the text below (in a fenced code block) does not contain trailing spaces: Like Barley Bending Like barley bending In low fields by the sea, Singing in hard wind Ceaselessly; Like barley bending And rising again, So would I, unbroken, Rise from pain; So would I softly, Day long, night long, Change my sorrow Into song. --- Sara Teasdale After we select the above poem and click the RStudio addin “Quote Poem”, the output will be: Like Barley Bending Like barley bending In low fields by the sea, Singing in hard wind Ceaselessly; Like barley bending And rising again, So would I, unbroken, Rise from pain; So would I softly, Day long, night long, Change my sorrow Into song. — Sara Teasdale Some users may ask, “Since the fenced code block preserves whitespaces, why not putting poems in code blocks?” Code could be poetic, but poems are not code. Do not be too addicted to coding. "],
["code-appendix.html", "3.9 Put together all code in the appendix", " 3.9 Put together all code in the appendix Unless the target readers are highly interested in the computational details while they read a report, you may not want to show the source code blocks in the report, but set the chunk option echo = FALSE to hide the source code instead, so readers will not be distracted by the program code for computing. However, the source code is still important for the sake of reproducible research. Sometimes readers may want to verify the computational correctness after they have finished reading the report. In this case, it can be a good idea to hold all code blocks in the body of the report, and display them at the end of a document (e.g., in an appendix). There is a simple method of extracting all code chunks in a document and put them together in a single code chunk using the chunk option ref.label (label references) and the function knitr::all_labels(), e.g., # Appendix: All code for this report ```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE} ``` The chunk option ref.label takes a vector of chunk labels to retrieve the content of these chunks. For example, the code chunk with the label chunk-a is the combination of chunk-c and chunk-b below: ```{r chunk-a, ref.label=c(&#39;chunk-c&#39;, &#39;chunk-b&#39;)} ``` ```{r chunk-b} # this is the chunk b 1 + 1 ``` ```{r chunk-c} # this is the chunk c 2 + 2 ``` In other words, chunk-a is essentially this: ```{r chunk-a} # this is the chunk c 2 + 2 # this is the chunk b 1 + 1 ``` The chunk option ref.label has provided a very flexible way of reorganizing code chunks in a document without resorting to cut-and-paste. It does not matter if the code chunks referenced are before or after the code chunk that uses ref.label. An early code chunk can reference a later chunk. The function knitr::all_labels() returns a vector of all chunk labels in the document, so ref.label = knitr::all_labels() means retrieving all source code chunks to this code chunk. With the chunk options echo = TRUE (display the code) and eval = FALSE (do not evaluate this particular code chunk because all code has been executed before), you can show a copy of all your source code in one code chunk. Since ref.label can be a character vector of arbitrary chunk labels, you can certainly filter the labels to decide a subset of code chunks to display in the code appendix. Below is an example (credits to Ariel Muldoon) of excluding the labels setup and get-labels: ```{r get-labels, echo = FALSE} labs = knitr::all_labels() labs = setdiff(labs, c(&quot;setup&quot;, &quot;get-labels&quot;)) ``` ```{r all-code, ref.label=labs, eval=FALSE} ``` You can also filter code chunks using the arguments of knitr::all_labels(). For example, you may use knitr::all_labels(engine == &quot;Rcpp&quot;, echo == FALSE) to obtain all your code chunks that use the Rcpp engine (engine == &quot;Rcpp&quot;) and are not displayed in the document (echo = FALSE). If you want precise control over which code chunks to display in the appendix, you may use a special chunk option appendix = TRUE on certain code chunks, and ref.label = knitr::all_labels(appendix == TRUE) to obtain the labels of these code chunks. "],
["equatiomatic.html", "3.10 Convert models to equations", " 3.10 Convert models to equations The equatiomatic package (https://github.com/datalorax/equatiomatic) developed by Daniel Anderson et al. provides a convenient and automatic way to show the equations corresponding to models fitted in R. At the time of writing, this package is still very new on GitHub and its API may change significantly before its possible future CRAN release, so we only show a few brief examples below: fit &lt;- lm(mpg ~ cyl + disp, mtcars) # show the theoretical model equatiomatic::extract_eq(fit) \\[ \\text{mpg} = \\alpha + \\beta_{1}(\\text{cyl}) + \\beta_{2}(\\text{disp}) + \\epsilon \\] # display the actual coefficients equatiomatic::extract_eq(fit, use_coefs = TRUE) \\[ \\text{mpg} = 34.66 - 1.59(\\text{cyl}) - 0.02(\\text{disp}) + \\epsilon \\] To display the actual math equations, you need the chunk option results = &quot;asis&quot;, otherwise the equations will be displayed as normal text output. Please read the documentation and follow the development of this package on GitHub if you are interested in knowing more about it. "],
["animation.html", "3.11 Create an animation from multiple R plots", " 3.11 Create an animation from multiple R plots When you generate a series of plots in a code chunk, you can combine them into an animation. It is easy to do so if the output format is HTML—you only need to install the gifski package and set the chunk option animation.hook = &quot;gifski&quot;. Figure 3.2 shows a simple “Pac-man” animation created from the code chunk below: ```{r, animation.hook=&quot;gifski&quot;} for (i in 1:2) { pie(c(i %% 2, 6), col = c(&#39;red&#39;, &#39;yellow&#39;), labels = NA) } ``` FIGURE 3.2: A Pac-man animation. The image format of the animation is GIF, which works well for HTML output, but it is not straightforward to support GIF in LaTeX. That is why you only see two static image frames if you are reading the PDF or printed version of this book in Figure 3.2. If you read the online version of this book, you will see the actual animation. Animations can work in PDF, but there are two prerequisites. First, you have to load the LaTeX package animate (see Section 5.3 for how). Second, you can only use Acrobat Reader to view the animation. Then the chunk option fig.show = &quot;animate&quot; will use the animate package to create the animation. Below is an example: --- title: Animations in PDF output: pdf_document: extra_dependencies: animate --- The animation below can only be viewed in Acrobat Reader. ```{r, fig.show=&#39;animate&#39;} for (i in 1:2) { pie(c(i %% 2, 6), col = c(&#39;red&#39;, &#39;yellow&#39;), labels = NA) } ``` The time interval between image frames in the animation can be set by the chunk option interval. By default, interval = 1 (i.e., one second). The R package animation (https://github.com/yihui/animation) contains several animation examples to illustrate methods and ideas in statistical computing. The gganimate package (https://github.com/thomasp85/gganimate) allows us to create smooth animations based on ggplot2. Both packages work with R Markdown. "],
["comments.html", "3.12 Comment out text", " 3.12 Comment out text It is useful to comment out text in the source document, which will not be displayed in the final output document. We can use the HTML syntax &lt;!-- your comment --&gt;. The comments will not be displayed in any output format. Comments can span either a single line or multiple lines. This may be useful for you to write draft content. "],
["toc-unlisted.html", "3.13 Omit a heading in the table of contents", " 3.13 Omit a heading in the table of contents If you do not want certain section headings to be included in the table of contents, you can add two classes to the heading: unlisted and unnumbered. For example: # Section heading {.unlisted .unnumbered} Note that this feature requires at least Pandoc 2.8. You may check your Pandoc version via rmarkdown::pandoc_version(). If the version is lower than 2.8, you may install a newer version by following the instructions at https://pandoc.org/installing.html. "],
["formatting.html", "Chapter 4 Formatting", " Chapter 4 Formatting The greatest strength of the Markdown language is that its simplicity makes it very easy to read and write even to newcomers. This is one of its key design principles, and as outlined creator of the original Markdown language: A Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. — John Gruber However, this comes at a cost of customization. Many features of typical word processors are not directly available in Markdown. These include: Changing the font size of a piece of text; Changing the font color of certain words; Specifying text alignment. We leave it to you to decide whether such features are worth your effort. To some degree, Markdown reflects the philosophy of Stoicism: the “natural world” consists of plain text, and you should not be controlled by the desire for (visual) pleasure. Anyway, this chapter offers some tips on how you can customize the appearance and styling of elements in an R Markdown document. If you need a reminder in the basics of the Markdown language, the R Markdown cheatsheet at https://www.rstudio.com/resources/cheatsheets/ provides a good overview of the basic syntax. "],
["font-color.html", "4.1 Font color", " 4.1 Font color The Markdown syntax has no built-in method for changing text colors. We can use HTML and LaTeX syntax to change the formatting of words: For HTML, we can wrap the text in the &lt;span&gt; tag and set color with CSS, e.g., &lt;span style=&quot;color: red;&quot;&gt;text&lt;/span&gt;. For PDF, we can use the LaTeX command \\textcolor{}{}. This requires the extra LaTeX package xcolor. As an example of changing the color in PDF text: --- output: pdf_document: extra_dependencies: [&quot;xcolor&quot;] --- Roses are \\textcolor{red}{red}, violets are \\textcolor{blue}{blue}. If you want to design an R Markdown document for multiple output formats, you should not embed raw HTML or LaTeX code in your document, because they will be ignored in the other output formats (e.g., LaTeX code will be ignored in HTML output). We can write a custom function to insert the correct syntax depending on the output format using the is_latex_output() and is_html_output() functions in knitr as follows: colorize &lt;- function(x, color) { if (knitr::is_latex_output()) { sprintf(&quot;\\\\textcolor{%s}{%s}&quot;, color, x) } else if (knitr::is_html_output()) { sprintf(&quot;&lt;span style=&#39;color: %s;&#39;&gt;%s&lt;/span&gt;&quot;, color, x) } else x } We can then use the code in an inline R expression `r colorize(&quot;some words in red&quot;, &quot;red&quot;)`, which will create some words in red (you may not see the red color if you are reading this book printed in black and white). "],
["indent-text.html", "4.2 Indent text", " 4.2 Indent text As mentioned in Section 3.8, whitespaces are often meaningless in Markdown. Markdown will also ignore spaces used for indentation by default. However, we may want to keep the indentation in certain cases, e.g., in verses and addresses. In these situations, we can use line blocks by starting the line with a vertical bar (|). The linebreaks and any leading spaces will be preserved in the output. For example:1 | When dollars appear it&#39;s a sign | that your code does not quite align | Ensure that your math | in xaringan hath | been placed on a single long line The output is: When dollars appear it’s a sign   that your code does not quite align Ensure that your math   in xaringan hath   been placed on a single long line The lines can be hard-wrapped in the Markdown source. If the continuation line begins with a space, the previous linebreak and the leading spaces on this line will be ignored as usual. For example: | Hiring Manager | School of Ninja, Hacker&#39;s University | 404 Not Found Road, Undefined 0x1234, NA The output is: Hiring Manager School of Ninja, Hacker’s University 404 Not Found Road, Undefined 0x1234, NA You can see that the linebreak after “School of Ninja” was ignored. This is a limerick written by Claus Ekstrøm: https://yihui.org/en/2018/06/xaringan-math-limerick/.↩ "],
["number-lines.html", "4.3 Line numbers for code blocks", " 4.3 Line numbers for code blocks You can add line numbers to either source code blocks via the chunk option attr.source = &quot;.numberLines&quot; or text output blocks via attr.output = &quot;.numberLines&quot;, e.g., ```{r, attr.source=&#39;.numberLines&#39;} if (TRUE) { 1:10 } ``` The output is: if (TRUE) { x &lt;- 1:10 x + 1 } Note that for HTML output, you have to choose a syntax highlighting theme provided by Pandoc, which means the highlight option of the output format should not be default or textmate. You can use other values for this option listed on the help page ?rmarkdown::html_document, e.g., output: html_document: highlight: tango For bookdown’s gitbook output format, you may need to adjust the CSS a little bit for the line numbers to be displayed properly on the left side of the code. Below is what we used for this book (if you find the line numbers too close to the left margin, increase the left value to, say, -2em): pre.numberSource a.sourceLine { left: -3em; } See Section 6.1 if you do not know how to apply custom CSS styles to HTML output. You can also specify the starting number via the startFrom attribute, e.g., ```{r, attr.source=&#39;.numberLines startFrom=&quot;5&quot;&#39;} if (TRUE) { 1:10 } ``` "],
["verbatim-code-chunks.html", "4.4 Verbatim code chunks", " 4.4 Verbatim code chunks Typically we write code chunks and inline expressions that we want to be parsed and evaluated by knitr. However, if you are trying to write a tutorial on using knitr, you may need to generate verbatim code chunk or inline expression that is not parsed by knitr, and we want to display the content of the chunk header. Unfortunately, we can’t wrap the code chunk in another layer of backticks, but instead we must make the code chunk invalid within the source code by inserting “ to the chunk header. This will be evaluated as an inline expression to an empty string by knitr. For this example, the following”code chunk&quot; in the source document: `r &#39;&#39;````{r, eval=TRUE} 1 + 1 ``` will be rendered as: ```{r, eval=TRUE} 1 + 1 ``` in the output. The inline expression is gone because it is substituted by an empty string. However, that is only the first step. To show something verbatim in the output, the syntax in Markdown is to wrap it in a code block (indent by four spaces or use backtick fences). This will be the actual source if you want to see the output above: ```` ```{r, eval=TRUE}`r &#39;&#39;` 1 + 1 ``` ```` Why four backticks? That is because you have to use at least N+1 backticks to wrap up N backticks. 4.4.1 Show a verbatim inline expression There are multiple ways to show a verbatim inline expression. I mentioned this trick for R Markdown documents in the FAQ: This will show a verbatim inline R expression `` `r 1+1` `` in the output. The trick works due to two reasons (1) a single line break is often the same as a space to Markdown parsers (by comparison, two consecutive line breaks means starting a new paragraph); (2) knitr requires a space after `r to parse it; if the space is missing, it will not be treated as an inline expression. In the output document, you should see: This will show a verbatim inline R expression `r 1+1` in the output. Another way to show a verbatim inline R expression is to wrap the R code in knitr::inline_expr(), e.g., This will show a verbatim inline R expression `` `r knitr::inline_expr(&quot;1+1&quot;)` `` in the output. "],
["multi-column-layout.html", "4.5 Multi-column layout", " 4.5 Multi-column layout Pandoc’s Markdown supports the multi-column layout for slides but not other types of documents. In this recipe, we show how to use the multi-column layout in normal HTML documents and LaTeX documents. This recipe was inspired by Atsushi Yasumoto’s solutions to the knitr issue https://github.com/yihui/knitr/issues/1743. The recipe will be much simpler if you only need to consider HTML output, because arranging HTML elements side by side is relatively simple via CSS. It will be even simpler if you only need to arrange the text output of a code chunk side by side. Below is the first example: --- output: html_document --- ```{r attr.source=&quot;style=&#39;display:inline-block;&#39;&quot;, collapse=TRUE} 1:10 # a sequence from 1 to 10 10:1 # in the reverse order ``` The CSS attribute display: inline-block; means the output code blocks (i.e., the &lt;pre&gt; tags in HTML) should be displayed as inline elements. By default, these blocks are displayed as block-level elements (i.e., display: block;) and will occupy whole rows. The chunk option collapse = TRUE means the text output will be merged into the R source code block, so both the source and its text output will be placed in the same &lt;pre&gt; block. If you want to arrange arbitrary content side by side in HTML output, you can use Pandoc’s fenced Div. The name “Div” comes from the HTML tag &lt;div&gt;, but you can interpret it as an arbitrary block or container. A Div starts and ends with three or more colons (e.g., :::). A Div with more colons can contain Divs with fewer colons. An important and useful feature of the fenced Div is that you can attach attributes to it. For example, you can apply the CSS attribute display: flex; to an outside container, so that the inside containers will be placed side by side: --- output: html_document --- :::: {style=&quot;display: flex;&quot;} ::: {} Here is the **first** Div. ```{r} str(iris) ``` ::: ::: {} And this block will be put on the right: ```{r} plot(iris[, -5]) ``` ::: :::: In the above example, the outside Div (::::) contains two Divs (:::). You can certainly add more Divs inside. To learn more about the very powerful CSS attribute display: flex; (CSS Flexbox), you may read the guide at https://css-tricks.com/snippets/css/a-guide-to-flexbox/. The CSS Grid (display: grid;) is also very powerful and can be used in the above example, too. If you want to try it, you may change display: flex; to display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;. See the guide at https://css-tricks.com/snippets/css/complete-guide-grid/ if you want to learn more about the grid layout. It is trickier if you want the layout to work for both HTML and LaTeX output. We show a full example below that works for HTML document, LaTeX document, and Beamer presentation output: --- output: html_document: css: columns.css beamer_presentation: default pdf_document: keep_tex: true includes: in_header: columns.tex --- # Two columns Below is a Div containing three child Divs side by side. The Div in the middle is empty, just to add more space between the left and right Divs. :::::: {.columns} ::: {.column width=&quot;55%&quot;} ```{r, echo=FALSE, fig.width=5, fig.height=4} par(mar = c(4, 4, .2, .1)) plot(cars, pch = 19) ``` ::: ::: {.column width=&quot;5%&quot;} \\ &lt;!-- an empty Div (with a whitespace), serving as a column separator --&gt; ::: ::: {.column width=&quot;40%&quot;} The figure on the left-hand side shows the `cars` data. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. ::: :::::: FIGURE 4.1: A two-column layout that works for HTML, LaTeX, and Beamer output. Figure 4.1 shows the output. In this example, we used an outside Div with the class .columns and three inside Divs with the class .column. For HTML output, we introduced an external CSS file columns.css, in which we applied the Flexbox layout to the outside Div so the inside Divs can be placed side by side: .columns {display: flex; } For Beamer output, there is nothing we need to do, because the LaTeX class beamer.cls has defined environments columns and column. They will just work. For LaTeX output (pdf_document), we have to introduce some dirty hacks stored in columns.tex to the LaTeX preamble to define the LaTeX environments columns and column: \\newenvironment{columns}[1][]{}{} \\newenvironment{column}[1]{\\begin{minipage}{#1}\\ignorespaces}{% \\end{minipage} \\ifhmode\\unskip\\fi \\aftergroup\\useignorespacesandallpars} \\def\\useignorespacesandallpars#1\\ignorespaces\\fi{% #1\\fi\\ignorespacesandallpars} \\makeatletter \\def\\ignorespacesandallpars{% \\@ifnextchar\\par {\\expandafter\\ignorespacesandallpars\\@gobble}% {}% } \\makeatother The column environment is particularly complicated mainly because Pandoc starts a new paragraph for each Div in LaTeX output, and we have to remove these new paragraphs, otherwise the Divs cannot be placed side by side. The hacks were borrowed from https://tex.stackexchange.com/q/179016/9128. "],
["latex-output.html", "Chapter 5 LaTeX Output", " Chapter 5 LaTeX Output For many authors, the main output of their work will be the PDF report, in which case they can utilize the powerful styling of LaTeX. In this chapter, we discuss approaches that can be used to customize the output of PDF reports. Users should approach with a note of caution. One of the major benefits of R Markdown is the fact that a single source document can create documents with multiple formats. By tailoring your work to a single output format, you may improve the appearance and performance of a single output format but at the expense of this transferability. "],
["latex-preamble.html", "5.1 Add LaTeX code to the preamble", " 5.1 Add LaTeX code to the preamble The general structure of a LaTeX document is like this: \\documentclass{article} % preamble \\begin{document} % body \\end{document} That is, you declare the document class in \\documentclass{}, load certain LaTeX packages and set certain options if necessary in the preamble, and start writing the body of your document after \\begin{document}. A Markdown document is mostly the body of the document. If you want to add anything to the preamble, you have to use the includes option of pdf_document. This option has three sub-options: in_header, before_body, and after_body. Each of them takes one or multiple file paths. The file(s) specified in in_header will be added to the preamble. The files specified in before_body and after_body are added before and after the document body, respectively. For example, below is a trick that turns the URLs in hyperlinks into footnotes. This trick is useful because (by default) readers do not know the actual URL when they see the text in PDF generated from \\href{URL}{text}. This trick displays both the text and URL. % you may want to save a copy of \\href before redefining it % \\let\\oldhref\\href \\renewcommand{\\href}[2]{#2\\footnote{\\url{#1}}} You can save the above code in a file with an arbitrary filename, e.g., preamble.tex. Then include it in the preamble through: output: pdf_document: includes: in_header: &quot;preamble.tex&quot; Another way to add code to the preamble is to use the header-includes field in the YAML frontmatter. We will show an example in Section 5.2. The advantage of using header-includes is that you can keep everything in one R Markdown document. However, if your report is to be generated into multiple output formats, we still recommend that you use the includes method, because the header-includes field is unconditional, and will be included in non-LaTeX output documents, too. By comparison, the includes option is only applied to the pdf_document format. "],
["latex-logo.html", "5.2 Add logo to title page", " 5.2 Add logo to title page We can use the titling LaTeX package to alter our title block to include an image. Below is a full example that shows how to add the R logo (logo.jpg) to the title page. The image can be of any format that LaTeX supports (e.g., jpg, png, or pdf). --- title: Adding a Logo to LaTeX Title author: Michael Harper date: December 7th, 2018 output: pdf_document header-includes: - \\usepackage{titling} - \\pretitle{\\begin{center} \\includegraphics[width=2in,height=2in]{logo.jpg}\\LARGE\\\\} - \\posttitle{\\end{center}} --- &lt;!-- Optionally include a page break. This will force the start of the document to the second page --&gt; \\newpage This is your report. ```{r, include=FALSE} # copy the R logo to the current directory file.copy(file.path(R.home(&quot;doc&quot;), &quot;html&quot;, &quot;logo.jpg&quot;), &#39;.&#39;) ``` An example output is shown in Figure 5.1. FIGURE 5.1: A logo on a LaTeX title page. An alternative method that does not require a special LaTeX package (titling) is to just insert the image to the title field using the Markdown syntax. For example: title: | ![](logo.jpg){width=1in} Adding a Logo to LaTeX Title In this case, you will not need the header-includes field in the YAML frontmatter in the first example. Please note that although you cannot see them, there are two trailing spaces after ![](logo.jpg){width=1in}, which means a linebreak in Markdown (see Section 3.8). Without the linebreak, the image and the title would be on the same line, which may not be what you desire. "],
["latex-extra.html", "5.3 Include additional LaTeX packages", " 5.3 Include additional LaTeX packages The use of additional LaTeX packages can allow for extensive customization of document styling. In addition, several packages such as kableExtra (Zhu 2019) may have LaTeX dependencies for the R package to function. Much like R, we need to load packages within the R Markdown document before we are able to use their functions. 5.3.1 Loading LaTeX packages We can load additional LaTeX packages using the extra_dependencies option within the pdf_document YAML settings. This allows us to provide a list of LaTeX packages to be loaded in the intermediate LaTeX output document, e.g., --- title: &quot;Using more LaTeX packages&quot; output: pdf_document: extra_dependencies: [&quot;bbm&quot;, &quot;threeparttable&quot;] --- If you need to specify options when loading the package, you can add a second-level to the list and provide the options as a list, e.g., output: pdf_document: extra_dependencies: caption: [&quot;labelfont={bf}&quot;] hyperref: [&quot;unicode=true&quot;, &quot;breaklinks=true&quot;] lmodern: null For those familiar with LaTeX, this is equivalent to the following LaTeX code: \\usepackage[labelfont={bf}]{caption} \\usepackage[unicode=true, breaklinks=true]{hyperref} \\userpackage{lmodern} 5.3.2 Example packages There is an extensive community for LaTeX, and there are over 4,000 packages available through the Comprohensive TeX Archive Network (CTAN). As some examples of LaTeX packages you could consider using within your report: pdfpages: include full PDF pages from an external PDF document within your document. caption: change the appearance of caption subtitles. For example, you can make the figure title italic or bold. fancyhdr: change the style of running headers of all pages. References "],
["latex-template.html", "5.4 Use a custom Pandoc LaTeX template", " 5.4 Use a custom Pandoc LaTeX template Pandoc converts Markdown to LaTeX through a template. The template is a LaTeX file containing Pandoc variables, and Pandoc will replace these variables with their values. Below is a simple template that only contains a single variable $body$: \\documentclass{article} \\begin{document} $body$ \\end{document} The value of $body$ is the LaTeX code generated from the body of the Markdown document. For example, if the body text is Hello **world**! in Markdown, the value of $body$ will be Hello \\textbf{world}!. If the LaTeX customization methods in Sections 5.1 and 5.3 are not enough for you, you may try to use a custom template instead. A template allows you to use arbitrary LaTeX code in it, hence is much more flexible. To use a template, include the path of the template in the template option of pdf_document, e.g., output: pdf_document: template: my-template.tex If you want to use Pandoc’s own LaTeX template, set template: null. The default LaTeX template in the rmarkdown package is a customized version of Pandoc’s LaTeX template. For the full list of Pandoc variables and their meanings, see Pandoc’s manual at https://pandoc.org/MANUAL.html#templates. "],
["figure-placement.html", "5.5 Control the placement of figures", " 5.5 Control the placement of figures One common frustration with LaTeX is the placement of figures and tables. Unlike in a word processor like Microsoft Word, in which figures are placed directly where the user specifies, LaTeX will attempt to place a figure in a position that does not violate certain typographic rules. In doing so, it can result in figures floating away from where they are referenced in the text. This section will explain some background information on how floating environments (such as figures) work, before providing several options for how to customize their behavior for your work. 5.5.1 Floating environments By default, figures with captions are generated with the figure environment in LaTeX. For example, Pandoc will convert the following Markdown code that contains an image ![This is a figure.](images/cool.jpg) to the LaTeX code: \\begin{figure} \\includegraphics{images/cool.jpg} \\caption{This is a figure.} \\end{figure} The figure environment is a floating environment. You can read a detailed description of floats at https://en.wikibooks.org/wiki/LaTeX/Floats,_Figures_and_Captions. In summary, floats are used as containers for things that cannot be broken over a page, such as tables and figures. If the figure or table can not be contained in the space left on the current page, LaTeX will try to place it at the top of the next page. If the figure is tall enough, it may occupy the whole next page, even if there is still space left for a few lines of text. The behavior can be controlled by different placement specifiers in square brackets after \\begin{figure}, e.g., \\begin{figure}[b]. Below is a list of possible specifiers: h: Place the float here, i.e., approximately at the same point it occurs in the source text. t: Position at the top of the page. b: Position at the bottom of the page. p: Put on a special page for floats only. !: Override internal parameters LaTeX uses for determining “good” float positions. H: Place the float at precisely the location in the LaTeX code. This requires the float package (\\usepackage{float}). These specifiers can be used in conjunction, e.g., !b forces LaTeX to place the figure at the bottom of a page. The default behavior is tbp. That is, LaTeX will try to position the figure at the top of the page, then at the bottom, and then on a separate page. 5.5.2 Prevent figures from floating Many users will initially want to prevent figures from floating in their document, replicating the behavior of a traditional word processor. To do this, we must firstly load the LaTeX package float. This can be done by including the following line in the YAML: output: pdf_document: extra_dependencies: [&quot;float&quot;] We can use the chunk option fig.pos to control the float behavior, and the use of !H will prevent any floating within the document. We can set the default behavior for the document so that all chunks have this setting by including the following line in the first code chunk in your R Markdown document: knitr::opts_chunk$set(fig.pos = &quot;!H&quot;, out.extra = &quot;&quot;) In general, we do not recommend that users force LaTeX to stop floating figures. This solution was included in this book by popular demand,2 but there could be some serious side-effects when LaTeX is unable to float figures. 5.5.3 Force floats forwards An alternative to forcing all floats to be held is to force floating forwards in the text. This can remove a common issue, where a figure is shown at the top of the page before the relevant text comes. This can break the reading flow of a report. We can force it so that the figure always appears after the text by using the flafter LaTeX package as follows: output: pdf_document: extra_dependencies: [&quot;flafter&quot;] 5.5.4 Adjust LaTeX placement rules LaTeX’s own float placement parameters could prevent placements that seem entirely “reasonable” to you—they are notoriously rather conservative. These defaults are displayed in Table 5.1. TABLE 5.1: Default LaTeX float settings. Command Description Default topfraction max fraction of page for floats at top 0.7 bottomfraction max fraction of page for floats at bottom 0.3 textfraction min fraction of page for text 0.2 floatpagefraction min fraction of page that should have floats 0.5 topnumber max number of floats at top of page 2 bottomnumber max number of floats at bottom of page 1 totalnumber max number of floats on a page 3 To encourage LaTeX not to move your figures, we can alter these default settings. We could include the following in our LaTeX preamble file, reducing the minimum amount of text required on a page and allow more room for floats: \\renewcommand{\\topfraction}{.85} \\renewcommand{\\bottomfraction}{.7} \\renewcommand{\\textfraction}{.15} \\renewcommand{\\floatpagefraction}{.66} \\setcounter{topnumber}{3} \\setcounter{bottomnumber}{3} \\setcounter{totalnumber}{4} If we have added these lines to a .tex file, we could include this file in the preamble of the LaTeX document using the method introduced in Section 5.1. The related Stack Overflow question has been viewed for over 45,000 times: https://stackoverflow.com/q/16626462/559676.↩ "],
["latex-header.html", "5.6 Add custom headers and footers", " 5.6 Add custom headers and footers The LaTeX package fancyhdr has provided several commands to customize the header and footer lines of your document. For a more complete guide, please refer to the full documentation at https://ctan.org/pkg/fancyhdr. To begin with, we must load the package. Then we can change the header style, e.g., \\usepackage{fancyhdr} \\pagestyle{fancy} The package offers three different interfaces, but we will use the commands \\fancyhead and \\fancyfoot. The syntax for the formatting is \\fancyhead[selectors]{output text}, whereby the selectors state the part of the header that we wish to customize. We can use the following selectors for the page locators: E for even pages O for odd pages L for the left side C for the center R for the right side For example, \\fancyhead[LE,RO]{Your Name} will print the text “Your Name” on the left side of the header for even pages, and the right side for odd pages. We can combine this with additional LaTeX commands to extract details from our document for each page: \\thepage: the number of the current page. \\thechapter: the number of the current chapter. \\thesection: the number of the current section. \\chaptername: the the word “Chapter” in English, or its equivalent in the current language, or the text that the author specified by redefining this command. \\leftmark: the name and number of the current top-level structure in uppercase letters. \\rightmark: the name and number of the current next to top-level structure in uppercase letters. Below is some example LaTeX code that you can add to the preamble using the methods introduced in Section 5.1: \\usepackage{fancyhdr} \\pagestyle{fancy} % center of header \\fancyhead[CO,CE]{Your Document Header} % center of footer \\fancyfoot[CO,CE]{And this is a fancy footer} % page number on the left of even pages and right of odd pages \\fancyfoot[LE,RO]{\\thepage} By default, headers and footers will not be displayed on the first page of your PDF document. If we wish to show our footer on the front page, we must include an additional line \\fancypagestyle{plain}{\\pagestyle{fancy}}. "],
["latex-subfigure.html", "5.7 LaTeX sub-figures", " 5.7 LaTeX sub-figures Sometimes you may want to include multiple images in a single figure environment. Sub-figures allow us to achieve this by arranging multiple images within a single environment and providing each with their own sub-caption. Sub-figures require the LaTeX package subfig. We can load it via the extra_dependencies YAML option within the pdf_document output. For example: --- output: pdf_document: extra_dependencies: &quot;subfig&quot; --- To arrange all plots from a code chunk in sub-figures, you have to use the chunk options fig.cap (the caption for the whole figure environment) and fig.subcap (a character vector of the captions for sub-figures). For best output, you can also use the following options: fig.ncol: The number of columns of sub-figures. By default, all plots are arranged in a single row. You can break them into multiple rows. out.width: The output width of individual plots. You will normally set this to 100% divided by the number of columns. For example, if you have two plots, the out.width option should be equal to or less than 50%, otherwise the plots may exceed the page margin. Below is an illustrative example: --- output: pdf_document: extra_dependencies: &quot;subfig&quot; --- ```{r fig-sub, fig.cap=&#39;All&#39;, fig.subcap=c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)} plot(1:10) plot(cars, pch = 19) boxplot(Sepal.Width ~ Species, data = iris) ``` The output is shown in Figure 5.2. For the sake of simplicity, we omitted a few chunk options in the chunk header of the above example, including fig.ncol = 2, out.width = &quot;50%&quot;, fig.align = &quot;center&quot;, and the actual long captions. FIGURE 5.2: An example of one figure environment containing multiple sub-figures. "],
["latex-hardcore.html", "5.8 For hardcore LaTeX users", " 5.8 For hardcore LaTeX users R Markdown is certainly not the best possible document format for authoring or typesetting documents. Simplicity is both its advantage and disadvantage. LaTeX is much more powerful than Markdown in terms of typesetting at the price of more commands to be typed. If typesetting is of much higher priority to you and you are comfortable with using all kinds of LaTeX commands and environments, you can just use pure LaTeX code instead of Markdown to write the whole document. The knitr package supports a variety of source document formats, including but not limited to R Markdown. Below is an example of intermingling R code with pure LaTeX code: \\documentclass{article} \\usepackage[T1]{fontenc} \\begin{document} Here is a code chunk. &lt;&lt;foo, fig.height=4&gt;&gt;= 1 + 1 par(mar = c(4, 4, .2, .2)) plot(rnorm(100)) @ You can also write inline expressions, e.g. $\\pi=\\Sexpr{pi}$, and \\Sexpr{1.9910214e28} is a big number. \\end{document} The filename usually has the extension .Rnw, e.g., the above file is latex.Rnw. The idea is the same but the syntax for writing R code chunks and inline R expressions is different. An R code chunk starts with &lt;&lt;&gt;&gt;= and ends with @. An inline R expression is written in \\Sexpr{}. The function knitr::knit() can compile an Rnw documents to a LaTeX (.tex) output file, which can be further compiled to PDF through your LaTeX tools such as pdflatex. You can also use knitr::knit2pdf() to compile Rnw to PDF in one step. If you use RStudio, you can hit the Compile PDF button on the toolbar. Please note that the default method to compile Rnw documents is through Sweave, and you may want to change it to knitr (see the post http://stackoverflow.com/q/27592837/559676 for how to do that). An Rnw document gives you the full power of LaTeX. This could be your last resort if there are typesetting problems that are really difficult to solve in Markdown. However, before you drop Markdown, we would like to remind you of the fact that a custom Pandoc LaTeX template may also be helpful (see Section 5.4). "],
["html-output.html", "Chapter 6 HTML Output", " Chapter 6 HTML Output Compared to LaTeX, HTML may be a little weak in typesetting for paged output, but it is much more powerful in presenting results, especially when combined with CSS and JavaScript. For example, you can embed interactive applications in HTML, and dynamically modify the appearance and even the content of an HTML page. Some useful yet simple CSS and JavaScript tricks for HTML output are very difficult (and often impossible) to reproduce in LaTeX output. In this chapter, we show examples on how to enhance your HTML output from R Markdown. "],
["html-css.html", "6.1 Apply custom CSS", " 6.1 Apply custom CSS We strongly recommend that you learn some CSS and JavaScript if you wish to customize the appearance of HTML documents. The Appendix B of the blogdown book [blogdown2017] contains short tutorials on HTML, CSS, and JavaScript. For beginners, it is extremely important to understand selectors and precedence of rules in CSS, otherwise you may be confused why your custom CSS rules do not work as expected (they may not have enough precedence). To include one or multiple custom stylesheets in an Rmd document, you can use the css option, e.g., output: html_document: css: &quot;style.css&quot; # or multiple sheets in an array # css: [&quot;style-1.css&quot;, &quot;style-2.css&quot;] Alternatively, you can use a css code chunk to embed the CSS rules directly in your Rmd document, e.g., We embed a `css` code chunk here. ```{css, echo=FALSE} p { font-size: 32px; } ``` The chunk option echo = FALSE means the CSS code will not be displayed verbatim in the output, but a &lt;style&gt; tag containing the CSS code will be generated to the HTML output file. "],
["html-template.html", "6.2 Use a custom HTML template", " 6.2 Use a custom HTML template We mentioned LaTeX templates in Section 5.4. You can also specify a custom HTML template for Pandoc to convert Markdown to HTML. Below is a brief example template: &lt;html&gt; &lt;head&gt; &lt;title&gt;$title$&lt;/title&gt; $for(css)$ &lt;link rel=&quot;stylesheet&quot; href=&quot;$css$&quot; type=&quot;text/css&quot; /&gt; $endfor$ &lt;/head&gt; &lt;body&gt; $body$ &lt;/body&gt; &lt;/html&gt; You can see that the template contains a few variables such as $title$ and $body$. You can find the full list of Pandoc variables and their meanings at https://pandoc.org/MANUAL.html#templates. The template gives you the ultimate power to customize the HTML output. For example, you can include arbitrary CSS stylesheets or JavaScript code or libraries in the &lt;head&gt; area. To apply a template to an Rmd document, you can save the template to a file, and pass the file path to the template option of html_document, e.g., output: html_output: template: my-template.html The rmarkdown package uses a custom HTML template shipped with the package, which is different from Pandoc’s default template. To use the latter, you can specify template: null. "],
["chunk-styling.html", "6.3 Style code blocks and text output", " 6.3 Style code blocks and text output We can customize the style of code chunks and their text output using the chunk options class.source and class.output, respectively. These options take character vectors of class names. For example, when class.source = &quot;important&quot;, the HTML element containing the code chunk in the output will have a class important. Then you can define CSS rules for this class. This can be useful when you want to highlight a certain code chunk or its text output. By default, the HTML output of R Markdown includes the Bootstrap framework, which makes it easy for you to change the appearance of your code and output, because Bootstrap has predefined some CSS classes for backgrounds:: &quot;bg-primary&quot;, &quot;bg-success&quot;, &quot;bg-info&quot;, &quot;bg-warning&quot;, and &quot;bg-danger&quot;. Below is an example using the chunk options class.source = &quot;bg-danger&quot; and class.output = &quot;bg-warning&quot;, and you can see its output in Figure 6.1. --- title: Change the chunk style output: html_document --- When you subset a data frame, it does not necessarily return a data frame. For example, if you subset two columns, you get a data frame, but when you try to subset one column, you get a vector: ```{r class.source=&quot;bg-danger&quot;, class.output=&quot;bg-warning&quot;} mtcars[1:5, &quot;mpg&quot;] ``` To make sure that we always get a data frame, we have to use the argument `drop = FALSE`. Now we use the chunk option `class.source = &quot;bg-success&quot;`. ```{r df-drop-ok, class.source=&quot;bg-success&quot;} mtcars[1:5, &quot;mpg&quot;, drop = FALSE] ``` FIGURE 6.1: A code chunk and its text output with background colors defined by Bootstrap. You can also use arbitrary class names and define CSS rules accordingly. In this case, you will have to include your custom CSS rules using the methods mentioned in Section 6.1. Below is an example: --- title: Assign custom classes to chunks output: html_document --- First we define some CSS rules for a class `watch-out`. ```{css, echo=FALSE} .watch-out { background-color: lightpink; border: 3px solid red; font-weight: bold; } ``` Then we assign a class `watch-out` to the code chunk via the chunk option `class.source`. ```{r class.source=&quot;watch-out&quot;} mtcars[1:5, &quot;mpg&quot;] ``` The output style is shown in Figure 6.2. FIGURE 6.2: A code chunk with a light pink background color and a thick red border. If you want all code chunks in the document to use the custom style, you can set class.source in the global knitr options, e.g., knitr::opts_chunk$set(class.source = &quot;watch-out&quot;) "],
["html-scroll.html", "6.4 Scrollable code blocks", " 6.4 Scrollable code blocks When you have large amounts of code and/or verbatim text output to display on an HTML page, it may be desirable to limit their heights, otherwise the page may look overwhelmingly lengthy, which will make it difficult for those who do not want to read the details in the code or its text output to skip these parts. There are multiple ways to solve this problem. One solution is to use the code_fold option in the html_document format, which will fold code blocks in the output and readers can unfold them by clicking a button. output: html_document: code_fold: hide The other possible solution is to make the code blocks scrollable within a fixed height when they are too long. This can be achieved by the CSS properties max-height and overflow-y. Below is a full example with the output in Figure 6.3: --- title: Scrollable code blocks output: html_document --- ```{css, echo=FALSE} pre { max-height: 300px; overflow-y: auto; } pre[class] { max-height: 100px; } ``` We have defined some CSS rules to limit the height of code blocks. Now we can test if these rules work on code blocks and text output: ```{r} # pretend that we have a lot of code in this chunk if (1 + 1 == 2) { # of course that is true print(mtcars) # we just printed a lengthy data set } ``` Next we add rules for a new class `scroll-100` to limit the height to 100px, and add the class to the output of a code chunk via the chunk option `class.output`: ```{css, echo=FALSE} .scroll-100 { max-height: 100px; overflow-y: auto; background-color: inherit; } ``` ```{r, class.output=&quot;scroll-100&quot;} print(mtcars) ``` FIGURE 6.3: Scrollable code blocks using custom CSS. In the above example, we defined a global maximum height of 300px for all code blocks. Remember that code blocks are placed in &lt;pre&gt; tags in the HTML output. Then we limited the height of &lt;pre&gt; blocks with class attributes to 100px. That is what the CSS selector pre[class] means. By default, text output will be contained in &lt;pre&gt; &lt;/pre&gt;, and R code blocks are contained in &lt;pre class=&quot;r&quot;&gt; &lt;/pre&gt; (note that the &lt;pre&gt; tag has a class attribute here). The height of the text output from the second R code chunk is also 100px. That is because we assigned a custom class name scroll-100 to the output, and defined the maximum height to be 100px. If you want to specify different maximum heights for individual code blocks, you may see the example in Section 10.3. "],
["html-tabs.html", "6.5 Put content in tabs", " 6.5 Put content in tabs One natural way of organizing parallel sections in an HTML report is to use tabsets. This allows readers to view the content of different sections by clicking the tab titles instead of scrolling back and forth on the page. To turn sections into tabs, you can add a class attribute .tabset to the upper-level section header. Below is a full example: --- title: Use tabs to organize content output: html_document --- You can turn parallel sections to tabs in `html_document` output. ## Results {.tabset} ### Plots We show a scatter plot in this section. ```{r, fig.dim=c(5, 3)} par(mar = c(4, 4, .5, .1)) plot(mpg ~ hp, data = mtcars, pch = 19) ``` ### Tables We show the data in this tab. ```{r} head(mtcars) ``` The output is shown in Figure 6.4. Note that you can only see one tab at a time in reality. In this figure, we actually concatenated two screenshots for you to see both tabs. FIGURE 6.4: Turn sections into tabs. You can add another attribute .tabset-pills to the upper-level section header to add a “pill” effect to the tab, and the tab will have a dark blue background. ## Results {.tabset .tabset-pills} To end the tabset, you need to start a new section header of the upper level. The new section header can be empty, e.g., ## Results {.tabset} ### Tab One ### Tab Two ## {-} With the above unnumbered (`{-}`) and empty section header, we can end the tabset and continue to write more paragraphs. "],
["embed-rmd.html", "6.6 Embed the Rmd source file in the HTML output file", " 6.6 Embed the Rmd source file in the HTML output file When you share an HTML output page with others, they may want the Rmd source file, too. For example, they may want to change the Rmd source and compile the report by themselves. You can use the option code_download to embed a copy of the Rmd source file in the HTML output file: output: html_document: code_download: true After the option is turned on, the HTML output page will contain a download button, and readers of the page can hit the button to download the Rmd source file. "],
["embed-file.html", "6.7 Embed arbitrary files in the HTML output file", " 6.7 Embed arbitrary files in the HTML output file As mentioned in Section 6.6, we can embed a copy of the Rmd source document in the HTML output file. Sometimes the Rmd source file alone may not be enough to reproduce the report. For example, the report may need an external data file. There is a series of functions in the xfun package that enable you to embed arbitrary files in the HTML output file. To use these functions, make sure you have the following R packages available: xfun::pkg_load2(c(&quot;base64enc&quot;, &quot;htmltools&quot;, &quot;mime&quot;)) Then you can use one of the functions xfun::embed_file(), xfun::embed_dir(), or xfun::embed_files() in an R code chunk to embed one or multiple files or an entire directory in the HTML output, e.g., ```{r echo=FALSE} # a single file xfun::embed_file(&#39;source.Rmd&#39;) # multiple files xfun::embed_files(c(&#39;source.Rmd&#39;, &#39;data.csv&#39;)) # a directory xfun::embed_dir(&#39;data/&#39;, text = &#39;Download full data&#39;) ``` You can also provide the list of files programmatically, e.g., # embed all Rmd and csv files xfun::embed_files(list.files(&quot;.&quot;, &quot;[.](Rmd|csv)$&quot;)) For multiple files, they are first compressed to a zip file, and the zip file will be embedded. These functions return a link, which a reader can click on the HTML page to download the embedded file. You can learn more technical details behind these functions from the help page ?xfun::embed_file or the blog post at https://yihui.org/en/2018/07/embed-file/. "],
["html-hardcore.html", "6.8 For hardcore HTML users", " 6.8 For hardcore HTML users In Section 5.8, we mentioned that if you feel the constraint of Markdown (due to its simplicity) is too strong, you can embed code chunks in a pure LaTeX document instead of Markdown. Similarly, if you are familiar and comfortable with writing raw HTML code, you can intermingle code chunks with HTML, too. Such documents have the conventional filename extension .Rhtml. In an Rhtml document, code chunks are embedded between &lt;!--begin.rcode and end.rcode--&gt;, and inline R expressions are embedded in &lt;!--rinline --&gt;. Below is a full Rhtml example. You can save it to a file named test.Rhtml, and use knitr::knit(&quot;test.Rhtml&quot;) to compile it. The output will be an HTML (.html) file. In RStudio, you can also hit the Knit button on the toolbar to compile the document. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;A minimal knitr example in HTML&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--begin.rcode knitr::opts_chunk$set(fig.width=5, fig.height=5) end.rcode--&gt; &lt;p&gt;This is a minimal example that shows how &lt;strong&gt;knitr&lt;/strong&gt; works with pure HTML pages.&lt;/p&gt; &lt;p&gt;Boring stuff as usual:&lt;/p&gt; &lt;!--begin.rcode # a simple calculator 1 + 1 # boring random numbers set.seed(123) rnorm(5) end.rcode--&gt; &lt;p&gt;We can also produce plots (centered by the option &lt;code&gt;fig.align=&#39;center&#39;&lt;/code&gt;):&lt;/p&gt; &lt;!--begin.rcode cars-scatter, fig.align=&#39;center&#39; plot(mpg ~ hp, data = mtcars) end.rcode--&gt; &lt;p&gt;Errors, messages and warnings can be put into &lt;code&gt;div&lt;/code&gt;s with different &lt;code&gt;class&lt;/code&gt;es:&lt;/p&gt; &lt;!--begin.rcode sqrt(-1) # warning message(&#39;knitr says hello to HTML!&#39;) 1 + &#39;a&#39; # mission impossible end.rcode--&gt; &lt;p&gt;Well, everything seems to be working. Let&#39;s ask R what is the value of &amp;pi;? Of course it is &lt;!--rinline pi --&gt;.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; "],
["word.html", "Chapter 7 Word", " Chapter 7 Word To generate a Word document from R Markdown, you can use the output format word_document. If you want to include cross-references in the document, you may consider the output format bookdown::word_document2, as mentioned in Section 3.3. --- output: word_document: default bookdown::word_document2: default # for cross-references --- From our experience, the most frequently asked questions about Word output are: How to apply a custom Word template to the document? How to incorporate changes made in Word into the original R Markdown document? How to style individual document elements? We will address these questions in this chapter. "],
["word-template.html", "7.1 Custom Word templates", " 7.1 Custom Word templates You can apply the styles defined in a Word template document to new Word documents generated from R Markdown. Such a template document is also called a “style reference document”. The key is that you have to create this template document from Pandoc first, and change the style definitions in it later. Then pass the path of this template to the reference_docx option of word_document, e.g., --- output: word_document: reference_docx: &quot;template.docx&quot; --- As we just mentioned, the document template.docx has to be generated from Pandoc. You can create this template from an arbitrary R Markdown document with the word_document output format (the actual content of this document does not matter). Then open the .docx file, and edit the styles. FIGURE 7.1: Find the styles of a specific document element. Figure 7.1 shows that you can open the “Styles” window from the “HOME” tab in Word. When you move the cursor to a specific element in the document, an item in the styles list will be highlighted. If you want to modify the styles of this type of elements, you can click the dropdown menu on the highlighted item, and you will see a dialog box like Figure 7.2. FIGURE 7.2: Modify the styles of an element in a Word document. After you finish modifying the styles, you can save the document (with a filename that will not be accidentally overwritten), and use it as the template for future Word documents. When Pandoc renders a new Word document with a reference document (template), it will read the styles in the template and apply them to the new document. You may watch a short video at https://vimeo.com/110804387, or read the article at https://rmarkdown.rstudio.com/articles_docx.html for more detailed instructions on how to create a Word template with custom styles. You may also check out the Stack Overflow post at https://stackoverflow.com/q/37671868/559676 on how to change the style of tables (the method is the same, and the key is that you need to find the correct style name). "],
["word-redoc.html", "7.2 The two-way workflow between R Markdown and Word", " 7.2 The two-way workflow between R Markdown and Word While it is easy to generate a Word document from R Markdown, things can be particularly painful when someone else edits the Word document and you have to manually port the changes back to the original R Markdown document. Luckily, Noam Ross has provided a promising solution to this problem. The redoc package (https://github.com/noamross/redoc) allows you to generate a Word document, revise the Word document, and convert the revised Word document back to R Markdown. Please note that as of this writing (January 2020), the redoc package is still experimental and has not been published to CRAN yet. You need to install it with: remotes::install_github(&quot;noamross/redoc&quot;) Once the package is installed, you may use the output format redoc::redoc: --- output: redoc::redoc --- This output format generates a Word document that actually stores the original Rmd document, so the Word document can be converted back to Rmd. Text written with the CriticMarkup syntax (http://criticmarkup.com) will be converted to tracked changes in Word, e.g., {++ important ++} means you want to insert a word “important” in the text. You can convert the Word document generated by redoc::redoc to Rmd via the function redoc::dedoc(), e.g., redoc::dedoc(&quot;file.docx&quot;) will generate file.Rmd. In this process, you can decide how to deal with tracked changes in Word via the track_changes argument, e.g., you may accept or reject changes, or convert tracked changes to CriticMarkup. When editing the Word document, you are expected to edit the parts that are not automatically generated by code chunks or inline R expressions in R Markdown. For example, you must not edit a table if it is automatically generated by knitr::kable() in a code chunk, because such changes will be lost when you convert Word to Rmd via dedoc(). To avoid accidentally editing the automatic results from code chunks, you may set the option highlight_outputs to true in the redoc::redoc format, which means the automatic output will be highlighted in Word (with a background color). You should tell your collaborator that they should not touch these highlighted parts in the Word document. The redoc package is still very young, so the introduction here is intentionally brief. When in doubt, we recommend that you read its documentation on GitHub. "],
["word-officedown.html", "7.3 Style individual elements", " 7.3 Style individual elements Due to the simplicity of Markdown, you can apply some global styles to the Word document (see Section 7.1), but it is not straightforward to style individual elements, such as changing the color of a word, or centering a paragraph. Continuing his effort on making it easier to work with Office documents in R, David Gohel started to develop the officedown package (https://github.com/davidgohel/officedown) in 2018, which aims to bring some officer (https://github.com/davidgohel/officer) features into R Markdown. As of this writing, this package has not been published on CRAN yet, and you need to install it from GitHub: remotes::install_github(&quot;davidgohel/officedown&quot;) After the package is installed, you need to load it in your R Markdown document, e.g., ```{r, setup, include=FALSE} library(officedown) ``` The officedown package allows you to style specific elements for the Word output. It has provided two types of syntax, and you can choose to use either one: You can call functions of this package in inline R expressions, e.g., `r chunk_styled_text(&quot;officedown is great&quot;, color = &quot;red&quot;, bold = TRUE)`. Or you can write the text in special HTML comments, e.g., &lt;!---CHUNK_TEXT{str: &quot;officedown is great&quot;, color: &quot;red&quot;, bold: true}---&gt;. The two ways are equivalent—the latter way essentially calls a corresponding function in officedown, e.g., when officedown detects the tag CHUNK_TEXT in the comment, it calls the function chunk_styled_text() with the parameters specified in the curly brackets in the comment. You may see the GitHub repository of officedown for the available tags and functions. Other things you may do with officedown include: Insert page breaks. Assign style names to text. Put content in a multi-column layout. Change paragraph settings. Insert a table of contents. Embed another Word document in the current document. Change the orientation of a section (landscape or portrait). "],
["multi-formats.html", "Chapter 8 Multiple Output Formats", " Chapter 8 Multiple Output Formats One main benefit of R Markdown is that it can create multiple output formats from a single source format, which could be one or multiple Rmd documents. For example, this book was written in R Markdown and compiled to three formats: PDF, ePub, and HTML. Sometimes it can be challenging to make an output element of a code chunk work for all output formats. For example, it is extremely simple to create a rounded and circular image in HTML output with a single CSS rule (img { border-radius: 50%; }), but not so straightforward in LaTeX output (typically it will involve TikZ graphics). Sometimes it is just impossible for an output element to work for all output formats. For example, you can easily create a GIF animation with the gifski package (see Section 3.11), and it will work perfectly for HTML output, but embedding such an animation in LaTeX output is not possible without extra steps of processing the GIF file and using extra LaTeX packages. This chapter aims to provide several examples on how a document can be customized with output-specific features, while retaining the ability to export documents to multiple formats. "],
["latex-html.html", "8.1 LaTeX or HTML output", " 8.1 LaTeX or HTML output LaTeX and HTML are two commonly used output formats. The function knitr::is_latex_output() tells you if the output format is LaTeX (including Pandoc output formats latex and beamer). Similarly, the function knitr::is_html_output tells you if the output format is HTML. By default, these Pandoc output formats are considered HTML formats: markdown, epub, html, html4, html5, revealjs, s5, slideous, and slidy. If you do not think a certain Pandoc format is HTML, you may use the excludes argument to exclude it, e.g., # do not treat markdown as an HTML format knitr::is_html_output(excludes = &quot;markdown&quot;) ## [1] TRUE If a certain output element can only be generated in LaTeX or HTML, you can use these functions to conditionally generate it. For example, when a table is too big on a PDF page, you may include the table in an environment of a smaller font size, but such a LaTeX environment certainly will not work for HTML output, so it should not be included in HTML output (if you want to tweak the font size for HTML output, you may use CSS). Below is a full example: --- title: Render a table in a tiny environment output: pdf_document: default html_document: default --- ```{r, setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) options(knitr.table.format = function() { if (knitr::is_latex_output()) &#39;latex&#39; else &#39;pandoc&#39; }) ``` The LaTeX environment `tiny` is only generated for LaTeX output. ```{r, include=knitr::is_latex_output()} knitr::asis_output(&#39;\\n\\n\\\\begin{tiny}&#39;) ``` ```{r} knitr::kable(mtcars) ``` ```{r, include=knitr::is_latex_output()} knitr::asis_output(&#39;\\\\end{tiny}\\n\\n&#39;) ``` By comparison, below is the table with the normal font size. ```{r} knitr::kable(mtcars) ``` The key in the above example is the chunk option include = knitr::is_latex_output(). That is, the environment \\begin{tiny} \\end{tiny} is only included when the output format is LaTeX. The two tables in the example will look identical when the output format is not LaTeX. In Section 4.1, we used these functions to change the text color for HTML and LaTeX output. In Section 3.11, we showed an animation example, which also used this trick. The code chunk that generated the animation for HTML output and static images for LaTeX output is like this: ```{r animation.hook=if (knitr::is_html_output()) &#39;gifski&#39;} for (i in 1:2) { pie(c(i %% 2, 6), col = c(&#39;red&#39;, &#39;yellow&#39;), labels = NA) } ``` These conditional functions can be used anywhere. You can use them in other chunk options (e.g., eval for conditional evaluation of the chunk), or in your R code, e.g., ```{r, eval=knitr::is_html_output(), echo=FALSE} cat(&#39;You will only see me in HTML output.&#39;) ``` ```{r} if (knitr::is_latex_output()) { knitr::asis_output(&#39;\\n\\n\\\\begin{tiny}&#39;) } ``` "],
["html-widgets.html", "8.2 Display HTML widgets", " 8.2 Display HTML widgets HTML widgets (https://htmlwidgets.org) are typically interactive JavaScript applications, which only work in HTML output. If you knit an Rmd document containing HTML widgets to a non-HTML format such as PDF or Word, you may get an error message like this: Error: Functions that produce HTML output found in document targeting X output. Please change the output type of this document to HTML. Alternatively, you can allow HTML output in non-HTML formats by adding this option to the YAML front-matter of your rmarkdown file: always_allow_html: yes Note however that the HTML output will not be visible in non-HTML formats. There is actually a better solution than the one mentioned in the above error message, but it involves extra packages. You can install the webshot package in R and also install PhantomJS: install.packages(&quot;webshot&quot;) webshot::install_phantomjs() Then if you knit an Rmd document with HTML widgets to a non-HTML format, the HTML widgets will be displayed as static screenshots. The screenshots are automatically taken in knitr. Section 2.10 of the bookdown book contains more information on finer control over the screenshots. "],
["figures-side.html", "8.3 Multiple figures side-by-side", " 8.3 Multiple figures side-by-side Ye can place multiple figures side-by-side using the fig.hold='hold' along with the out.width option. In the example below, we have set out.width=&quot;50%&quot;: par(mar = c(4, 4, 0.1, 0.1)) plot(cars) plot(mpg ~ hp, data = mtcars, pch = 19) FIGURE 8.1: Side-by-side figures. This simple approach works for both PDF and HTML output. "],
["custom-blocks.html", "8.4 Custom blocks", " 8.4 Custom blocks Section 2.7 of the bookdown book mentioned how we can use custom blocks in R Markdown to customize the appearance of blocks of content. This can be a useful way to make some content stand out from your report or book, to make sure that your readers take away the key points from your work. Examples of how these blocks could be used include: Display a warning message to make sure users are using up-to-date packages before running your analysis; Add a link at the beginning of your document to your GitHub repository containing the source; Highlight key results and findings from your analysis. In this section, we will explain how to create your own custom blocks for both PDF and HTML output. They can both use the same formatting syntax in the R Markdown document, but require different configurations. 8.4.1 Syntax The syntax for custom blocks is based on Pandoc’s fenced Div blocks. Div blocks are very powerful, but there is a problem at the moment: they mainly work for HTML output and do not work for LaTeX output. Since the version 1.16 of the rmarkdown package, it has been possible to convert Div blocks to both HTML and LaTeX. For HTML output, all attributes of the block will become attributes of the &lt;div&gt; tag. For example, a Div can have an ID (after #), one or multiple classes (class names are written after .), and other attributes. The following Div block ::: {#hello .greeting .message width=&quot;40%&quot;} Hello **world**! ::: will be converted to the HTML code below: &lt;div id=&quot;hello&quot; class=&quot;greeting message&quot; width=&quot;40%&quot;&gt; Hello &lt;strong&gt;world&lt;/strong&gt;! &lt;/div&gt; For LaTeX output, the first class name will be used as the LaTeX environment name, and you must provide an attribute named data-latex in the Div block, which will be the arguments of the environment. This attribute can be an empty string if the environment does not need arguments. We show two simple examples below. The first example uses the verbatim environment in LaTeX, which does not have any arguments: ::: {.verbatim data-latex=&quot;&quot;} We show some _verbatim_ text here. ::: Its LaTeX output will be: \\begin{verbatim} We show some \\emph{verbatim} text here. \\end{verbatim} When the block is converted to HTML, the HTML code will be: &lt;div class=&quot;verbatim&quot;&gt; We show some &lt;em&gt;verbatim&lt;/em&gt; text here. &lt;/div&gt; The second example uses the center and minipage environments to display some text in a centered box of half-width of the page width. :::: {.center data-latex=&quot;&quot;} ::: {.minipage data-latex=&quot;{width=.5\\linewidth}&quot;} This paragraph will be centered on the page, and its width is 50% of the width of its parent element. ::: :::: Note that we nest the minipage block in the center block. You need more colons for a parent block to include a child block. In the above example, we used four colons (you can use five or more) for the center block. The two blocks will be converted to LaTeX code below: \\begin{center} \\begin{minipage}{width=.5\\linewidth} This paragraph will be centered on the page, and its width is 50\\% of the width of its parent element. \\end{minipage} \\end{center} It is up to the user to define the appearance of their &lt;div&gt; blocks via CSS for the HTML output. Similarly, for LaTeX output, you may use the command \\newenvironment to define the environment if it has not been defined, or \\renewenvironment to redefine an existing environment in LaTeX. In the LaTeX definitions, you can decide the appearance of these blocks in PDF. These customizations will normally be contained in their own files such as style.css or preamble.tex, and then included within the YAML options: --- output: html_document: css: style.css pdf_document: includes: in_header: preamble.tex --- Next we will demonstrate a few more advanced custom blocks that use custom CSS rules and LaTeX environments. 8.4.2 Adding a shaded box First, we show how to include content in a shaded box. The box has a black background with an orange frame with rounded corners. The text in the box is in white. For HTML output, we define these rules in a CSS file. If you are unfamiliar with CSS, there are plenty of free online tutorials, e.g., https://www.w3schools.com/css/. .blackbox { padding: 1em; background: black; color: white; border: 2px solid orange; border-radius: 10px; } .center { text-align: center; } For LaTeX output, we create a new environment named blackbox and based on the LaTeX package framed, with a black background and white text: \\usepackage{color} \\usepackage{framed} \\setlength{\\fboxsep}{.8em} \\newenvironment{blackbox}{ \\definecolor{shadecolor}{rgb}{0, 0, 0} % black \\color{white} \\begin{shaded}} {\\end{shaded}} We used the framed package in this book because it is fairly lightweight, but it is not possible to draw a colored frame with rounded corners with this package. To achieve the latter, you will need more sophisticated LaTeX packages such as tcolorbox (https://ctan.org/pkg/tcolorbox), which offers a set of very flexible options for creating shaded boxes. You can find many examples in its documentation. The LaTeX environment below will create a shaded box of the similar appearance as the above CSS example: \\usepackage[many]{tcolorbox} \\newtcolorbox{blackbox}{ colback=black, colframe=orange, coltext=white, boxsep=5pt, arc=4pt} Now we can use our custom box in both PDF and HTML output formats. The source code of the box is: :::: {.blackbox data-latex=&quot;&quot;} ::: {.center data-latex=&quot;&quot;} **NOTICE!** ::: Thank you for noticing this **new notice**! Your noticing it has been noted, and _will be reported to the authorities_! :::: The output is: NOTICE! Thank you for noticing this new notice! Your noticing it has been noted, and will be reported to the authorities! 8.4.3 Including icons We can make custom blocks even more visually appealing by including images in them, and it can be an effective way to convey the content of the block. For the following example, we assume that we are working within a directory structure below, which is a simplified version of what is used to build this book: directory/ ├── your-report.Rmd ├── style.css ├── preamble.tex └── images/ └── ├── important.png ├── note.png └── caution.png We show the source code and output of the example before we explain how everything works: ::: {.infobox .caution data-latex=&quot;{caution}&quot;} **NOTICE!** Thank you for noticing this **new notice**! Your noticing it has been noted, and _will be reported to the authorities_! ::: The output is: NOTICE! Thank you for noticing this new notice! Your noticing it has been noted, and will be reported to the authorities! For the HTML output, we can add an image to the box through the background-image property in CSS. We insert the image into the background, and add enough padding on the left-hand side to avoid the text overlapping with this image. If you are using local images, the file path to the images is provided relative to the CSS file. For example: .infobox { padding: 1em 1em 1em 4em; margin-bottom: 10px; border: 2px solid orange; border-radius: 10px; background: #f5f5f5 5px center/3em no-repeat; } .caution { background-image: url(&quot;images/caution.png&quot;); } Note that we used two class names, .infobox and .caution, on the outer block. The infobox class will be used to define the shaded box with a colored border, and the caution class will be used to include the image. The advantage of using two classes is that we can define more blocks with different icons without repeating the setup of the shaded box. For example, if we need a warning box, we only need to define the CSS rule without repeating rules in .infobox: .warning { background-image: url(&quot;images/warning.png&quot;); } Then you can create a warning box with the Markdown source code below: :::: {.infobox .warning data-latex=&quot;warning&quot;} Include the actual content here. :::: For the PDF output, we can create an infobox environment based on the blackbox environment defined in the previous example, and add the icon to the left side of the box. There are multiple ways of including images in a LaTeX environment, and here is only one of them (it does not precisely reproduce the box style defined in CSS above): \\newenvironment{infobox}[1] { \\begin{itemize} \\renewcommand{\\labelitemi}{ \\raisebox{-.7\\height}[0pt][0pt]{ {\\setkeys{Gin}{width=3em,keepaspectratio} \\includegraphics{images/#1}} } } \\setlength{\\fboxsep}{1em} \\begin{blackbox} \\item } { \\end{blackbox} \\end{itemize} } Below we show more example blocks with different icons: NOTICE! Thank you for noticing this new notice! Your noticing it has been noted, and will be reported to the authorities! NOTICE! Thank you for noticing this new notice! Your noticing it has been noted, and will be reported to the authorities! NOTICE! Thank you for noticing this new notice! Your noticing it has been noted, and will be reported to the authorities! NOTICE! Thank you for noticing this new notice! Your noticing it has been noted, and will be reported to the authorities! "],
["chunk-options.html", "Chapter 9 Chunk Options", " Chapter 9 Chunk Options As illustrated in Figure 2.1, the R package knitr is one of the two major components of R Markdown (the other being Pandoc). In this chapter and the next three chapters, we show some recipes related to knitr. There are more than 50 chunk options that can be used to fine-tune the behavior of knitr when processing R chunks. Section 2.8 of the R Markdown Definitive Guide (Xie, Allaire, and Grolemund 2018) provides a subset of these options, while the full list is available at https://yihui.org/knitr/options/. In the following sections, we only show examples of applying chunk options to individual code chunks. However, please be aware of the fact that any chunk options can also be applied globally to a whole document, so you do not have to repeat the options in every single code chunk. To set chunk options globally, call knitr::opts_chunk$set() in a code chunk (usually the first one in the document), e.g., ```{r, include=FALSE} knitr::opts_chunk$set( comment = &quot;#&gt;&quot;, echo = FALSE, fig.width = 6 ) ``` References "],
["cache.html", "9.1 Cache time-consuming code chunks", " 9.1 Cache time-consuming code chunks When a code chunk is time-consuming to run, you may consider caching it via the chunk option cache = TRUE. When the cache is turned on, knitr will skip the execution of this code chunk if it has been executed before and nothing in the code chunk has changed since then. When you modify the code chunk (e.g., revise the code or the chunk options), the previous cache will be automatically invalidated, and knitr will cache the chunk again. For a cached code chunk, its output and objects will be automatically loaded from the previous run, as if the chunk were executed again. Caching is often helpful when loading results is much faster than computing the results. However, there is no free lunch. Depending on your use case, you may need to learn more about how caching (especially cache invalidation) works, so you can take the full advantage of it without confusing yourself why sometimes knitr invalidates your cache too often and sometimes there is not enough invalidation. The most appropriate use case of caching is to save and reload R objects that take too long to compute in a code chunk, and the code does not have any side-effects, such as changing global R options via options() (such changes will not be cached). If a code chunk has side-effects, we recommend that you do not cache it. As we briefly mentioned earlier, the cache depends on chunk options. If you change any chunk options (except the option include), the cache will be invalidated. This feature can be used to solve a common problem. That is, when you read an external data file, you may want to invalidate the cache when the data file is updated. Simply using cache = TRUE is not enough: ```{r import-data, cache=TRUE} d &lt;- read.csv(&#39;my-precious.csv&#39;) ``` You have to let knitr know if the data file has been changed. One way to do it is to add another chunk option cache.extra = file.mtime('my-precious.csv') or more rigorously, cache.extra = tools::md5sum('my-precious.csv'). The former means if the modification time of the file has been changed, we need to invalidate the cache. The latter means if the content of the file has been modified, we update the cache. Note that cache.extra is not a built-in knitr chunk option. You can use any other name for this option, as long as it does not conflict with built-in option names. Similarly, you can associate the cache with other information such as the R version (cache.extra = getRversion()), the date (cache.extra = Sys.Date()), or your operating system (cache.extra = Sys.info()[['sysname']]), so the cache can be properly invalidated when these conditions change. If you are not happy with knitr’s design for caching, you can certainly cache objects by yourself. Below is a quick example: if (file.exists(&quot;results.rds&quot;)) { res &lt;- readRDS(&quot;results.rds&quot;) } else { res &lt;- compute_it() # a time-consuming function saveRDS(res, &quot;results.rds&quot;) } In this case, the only (and also simple) way to invalidate the cache is to delete the file results.rds. "],
["cache-path.html", "9.2 Cache a code chunk for multiple output formats", " 9.2 Cache a code chunk for multiple output formats When caching is turned on via the chunk option cache = TRUE, knitr will write R objects generated in a code chunk to a cache database, so they can be reloaded the next time. The path to the cache database is determined by the chunk option cache.path. By default, R Markdown uses different cache paths for different output formats, which means a time-consuming code chunk will be fully executed for each output format. This may be inconvenient, but there is a reason for this default behavior: the output of a code chunk can be dependent on the specific output format. For example, when you generate a plot, the output for the plot could be Markdown code like ![text](path/to/image.png) when the output format is word_document, or HTML code like &lt;img src=&quot;path/to/image.png&quot; /&gt; when the output format is html_document. When a code chunk does not have any side-effects (such as plots), it is safe to use the same cache database for all output formats, which can save you time. For example, when you read a large data object or run a time-consuming model, the result does not depend on the output format, so you can use the same cache database. You can specify the path to the database via the chunk option cache.path on a code chunk, e.g., ```{r important-computing, cache=TRUE, cache.path=&quot;cache/&quot;} ``` By default, cache.path = &quot;INPUT_cache/FORMAT/&quot; in R Markdown, where INPUT is the input filename, and FORMAT is the output format name (e.g., html, latex, or docx). We do not recommend that you set cache = TRUE or cache.path globally in a document. Caching can be quite tricky. Instead, we recommend that you set these options only on individual code chunks that are surely time-consuming and do not have side-effects. "],
["hide-one.html", "9.3 Hide code, text output, messages, or plots", " 9.3 Hide code, text output, messages, or plots By default, knitr displays all possible output from a code chunk, including the source code, text output, messages, warnings, and plots. You can hide them individually using the corresponding chunk options. Hide source code: ```{r, echo=FALSE} 1 + 1 ``` Hide text output (you can also use `results = FALSE`): ```{r, results=&#39;hide&#39;} print(&quot;You will not see the text output.&quot;) ``` Hide messages: ```{r, message=FALSE} message(&quot;You will not see the message.&quot;) ``` Hide warning messages: ```{r, warning=FALSE} # this will generate a warning but it will be suppressed 1:2 + 1:3 ``` Hide plots: ```{r, fig.show=&#39;hide&#39;} plot(cars) ``` Note that the plot will be generated in the above chunk. It is just not displayed in the output. One frequently asked question about knitr is how to hide package loading messages. For example, when you library(tidyverse) or library(ggplot2), you may see some loading messages. Such messages can also be suppressed by the chunk option message = FALSE. You can also selectively show or hide these elements by indexing them. In the following example, we only show the fourth and fifth expressions of the R source code (note that a comment counts as one expression), the first two messages, and the second and third warnings: ```{r, echo=c(4, 5), message=c(1, 2), warning=2:3} # one way to generate random N(0, 1) numbers x &lt;- qnorm(runif(10)) # but we can just use rnorm() in practice x &lt;- rnorm(10) x for (i in 1:5) message(&#39;Here is the message &#39;, i) for (i in 1:5) warning(&#39;Here is the warning &#39;, i) ``` You can use negative indices, too. For example, echo = -2 means to exclude the second expression of the source code in the output. Similarly, you can choose which plots to show or hide by using indices for the fig.keep option. For example, fig.keep = 1:2 means to keep the first two plots. There are a few shortcuts for this option: fig.keep = &quot;first&quot; will only keep the first plot, fig.keep = &quot;last&quot; only keeps the last plot, and fig.keep = &quot;none&quot; discards all plots. Note that the two options fig.keep = &quot;none&quot; and fig.show = &quot;hide&quot; are different: the latter will generate plots but only hide them, and the former will not generate plot files at all. "],
["hide-all.html", "9.4 Hide everything from a chunk", " 9.4 Hide everything from a chunk Sometimes we may want to execute a code chunk without showing any output at all. Instead of using separate options mentioned in Section 9.3, we can suppress the entire output of the code chunk using a single option include = FALSE, e.g., ```{r, include=FALSE} # any R code here ``` With include=FALSE, the code chunk will be evaluated (unless eval=FALSE), but the output will be completely suppressed—you will not see any code, text output, messages, or plots. "],
["opts-comment.html", "9.5 Remove leading hashes in text output", " 9.5 Remove leading hashes in text output By default, R code output will have two hashes ## inserted in front of the text output. We can alter this behavior through the comment chunk option, which defaults to a character string &quot;##&quot;. We can use an empty string if we want to remove the hashes. For example: ```{r, comment=&quot;&quot;} 1:100 ``` Of course, you can use any other character values, e.g., comment = &quot;#&gt;&quot;. Why does the comment option default to hashes? That is because # indicates comments in R. When the text output is commented out, it will be easier for you to copy all the code from a code chunk in a report and run it by yourself, without worrying about the fact that text output is not R code. For example, in the code chunk below, you can copy all four lines of text and run them safely as R code: 1 + 1 ## [1] 2 2 + 2 ## [1] 4 If you remove the hashes via comment = &quot;&quot;, it will not be easy for you to run all the code, because if you copy the four lines, you will have to manually remove the second and fourth line: 1 + 1 [1] 2 2 + 2 [1] 4 One argument in favor of comment = &quot;&quot; is that it makes the text output look familiar to R console users. In the R console, you do not see hashes in the beginning of lines of text output. If you want to truly mimic the behavior of the R console, you can actually use comment = &quot;&quot; in conjunction with prompt = TRUE, e.g., ```{r, comment=&quot;&quot;, prompt=TRUE} 1 + 1 if (TRUE) { 2 + 2 } ``` The output should look fairly familiar to you if you have ever typed and run code in the R console, since the source code contains the prompt character &gt; and the continuation character +: &gt; 1 + 1 [1] 2 &gt; if (TRUE) { + 2 + 2 + } [1] 4 "],
["fig-process.html", "9.6 Post-process plots", " 9.6 Post-process plots After a plot is generated from a code chunk, you can post-process the plot file via the chunk option fig.process, which should be a function that takes the file path as the input argument and returns a path to the processed plot file. This function can have an optional second argument options, which is a list of the current chunk options. Below we show an example of adding an R logo to a plot using the extremely powerful magick package (Ooms 2019). If you are not familiar with this package, we recommend that you read its online documentation or package vignette, which contains lots of examples. First, we define a function add_logo(): add_logo &lt;- function(path, options) { # the plot created from the code chunk img &lt;- magick::image_read(path) # the R logo logo &lt;- file.path(R.home(&quot;doc&quot;), &quot;html&quot;, &quot;logo.jpg&quot;) logo &lt;- magick::image_read(logo) # the default gravity is northwest, and users can change # it via the chunk option magick.gravity if (is.null(g &lt;- options$magick.gravity)) g &lt;- &quot;northwest&quot; # add the logo to the plot img &lt;- magick::image_composite(img, logo, gravity = g) # write out the new image magick::image_write(img, path) path } Basically the function takes the path of an R plot, adds an R logo to it, and saves the new plot to the original path. By default, the logo is added to the upper-left corner (northwest) of the plot, but users can customize the location via the custom chunk option magick.gravity (this option name can be arbitrary). Now we apply the above processing function to the code chunk below with chunk options fig.process = add_logo and magick.gravity = &quot;northeast&quot;, so the logo is added to the upper-right corner. See Figure 9.1 for the actual output. par(mar = c(4, 4, 0.1, 0.1)) hist(faithful$eruptions, breaks = 30, main = &quot;&quot;, col = &quot;gray&quot;, border = &quot;white&quot;) FIGURE 9.1: Add the R logo to a plot via the chunk option fig.process. After you get more familiar with the magick package, you may come up with more creative and useful ideas to post-process your R plots. Last we show one more application of the fig.process option. The pdf2png() function below convert a PDF image to PNG. In Section 9.7, we have an example of using the tikz graphical device to generate plots. The problem is that this device generates PDF plots, which will not work for non-LaTeX output documents. With the chunk options dev = &quot;tikz&quot; and fig.process = pdf2png, we can show the PNG version of the plot in Figure 9.2. pdf2png &lt;- function(path) { # only do the conversion for non-LaTeX output if (knitr::is_latex_output()) return(path) path2 &lt;- xfun::with_ext(path, &quot;png&quot;) img &lt;- magick::image_read_pdf(path) magick::image_write(img, path2, format = &quot;png&quot;) path2 } References "],
["graphical-device.html", "9.7 High-quality graphics", " 9.7 High-quality graphics The rmarkdown package has set reasonable default graphical devices for different output formats. For example, HTML output formats use the png() device, so knitr will generate PNG plot files, and PDF output formats use the pdf() device, etc. If you are not satisfied by the quality of the default graphical devices, you can change them via the chunk option dev. All possible devices supported by knitr are: &quot;bmp&quot;, &quot;postscript&quot;, &quot;pdf&quot;, &quot;png&quot;, &quot;svg&quot;, &quot;jpeg&quot;, &quot;pictex&quot;, &quot;tiff&quot;, &quot;win.metafile&quot;, &quot;cairo_pdf&quot;, &quot;cairo_ps&quot;, &quot;quartz_pdf&quot;, &quot;quartz_png&quot;, &quot;quartz_jpeg&quot;, &quot;quartz_tiff&quot;, &quot;quartz_gif&quot;, &quot;quartz_psd&quot;, &quot;quartz_bmp&quot;, &quot;CairoJPEG&quot;, &quot;CairoPNG&quot;, &quot;CairoPS&quot;, &quot;CairoPDF&quot;, &quot;CairoSVG&quot;, &quot;CairoTIFF&quot;, &quot;Cairo_pdf&quot;, &quot;Cairo_png&quot;, &quot;Cairo_ps&quot;, &quot;Cairo_svg&quot;, &quot;svglite&quot;, and &quot;tikz&quot;. Usually a graphical device name is also a function name. If you want to know more about a device, you can read the R help page. For example, you can type ?svg in the R console to know the details about the svg device, which is included in base R. Note that the quartz_* devices are based on the quartz() function, and they are only available on macOS. The CairoXXX devices are from the add-on R package Cairo, the Cairo_xxx devices are from the cairoDevice package, the svglite device is from the svglite package, and tikz is a device in the tikzDevice package. If you want to use devices from an add-on package, you have to install the package first. Usually vector graphics have higher quality than raster graphics, and you can scale vector graphics without loss of quality. For HTML output, you may consider using dev = &quot;svg&quot; or dev = &quot;svglite&quot; for SVG plots. Note that SVG is a vector graphics format, and the default png device produces a raster graphics format. For PDF output, if you are really picky about the typeface in your plots, you may use dev = &quot;tikz&quot;, because it offers native support for LaTeX, which means all elements in a plot, including text and symbols, are rendered in high quality through LaTeX. Figure 9.2 shows an example of writing LaTeX math expressions in an R plot rendered with the chunk option dev = &quot;tikz&quot;. par(mar = c(4, 4, 2, .1)) curve(dnorm, -3, 3, xlab = &#39;$x$&#39;, ylab = &#39;$\\\\phi(x)$&#39;, main = &#39;The density function of $N(0, 1)$&#39;) text(-1, .2, cex = 3, col = &#39;blue&#39;, &#39;$\\\\phi(x)=\\\\frac{1}{\\\\sqrt{2\\\\pi}}e^{\\\\frac{-x^2}{2}}$&#39;) FIGURE 9.2: A plot rendered via the tikz device. Note that base R actually supports math expressions, but they are not rendered via LaTeX (see ?plotmath for details). There are several advanced options to tune the typesetting details of the tikz device. You may see ?tikzDevice::tikz for the possibilities. For example, if your plot contains multibyte characters, you may want to set the option: options(tikzDefaultEngine = &quot;xetex&quot;) That is because xetex is usually better than the default engine pdftex in processing multibyte characters in LaTeX documents. There are two major disadvantages of the tikz device. First, it requires a LaTeX installation, but this may not be too bad (see Section 1.1). Second, it is often significantly slower to render the plots, because this device generates a LaTeX file and has to compile it to PDF. If you feel the code chunk is time-consuming, you may enable caching by the chunk option cache = TRUE. For Figure 9.2, we also used the chunk option fig.process = pdf2png, where the function pdf2png is defined in Section 9.6 to convert the PDF plot to PNG when the output format is not LaTeX. Without the conversion, you may not be able to view the PDF plot in the online version of this book in the web browser. "],
["option-hooks.html", "9.8 Option hooks", " 9.8 Option hooks Sometimes you may want to change certain chunk options dynamically according to the values of other chunk options, and you may use the object opts_hooks to set up an option hook to do it. An option hook is a function associated with the option and to be executed when a corresponding chunk option is not NULL. For example, we can tweak the fig.width option so that it is always no smaller than fig.height: knitr::opts_hooks$set(fig.width = function(options) { if (options$fig.width &lt; options$fig.height) { options$fig.width &lt;- options$fig.height } options }) Because fig.width will never be NULL, this hook function is always executed before a code chunk to update its chunk options. For the code chunk below, the actual value of fig.width will be 6 instead of the initial 5 if the above option hook has been set up: ```{r fig.width = 5, fig.height = 6} plot(1:10) ``` As another example, we rewrite the last example in Section 9.5 so we can use a single chunk option console = TRUE to imply comment = &quot;&quot; and prompt = TRUE. Note that console is not a built-in knitr chunk option but a custom and arbitrary option name instead. Its default value will be NULL. Below is a full example: ```{r, include=FALSE} knitr::opts_hooks$set(console = function(options) { if (isTRUE(options$console)) { options$comment &lt;- &#39;&#39;; options$prompt &lt;- TRUE } options }) ``` Default output: ```{r} 1 + 1 if (TRUE) { 2 + 2 } ``` Output with `console = TRUE`: ```{r, console=TRUE} 1 + 1 if (TRUE) { 2 + 2 } ``` "],
["output-hooks.html", "Chapter 10 Output Hooks", " Chapter 10 Output Hooks With knitr, you have control over every piece of output from your code chunks, such as source code, text output, messages, and plots. The control is achieved through “output hooks”, which are a series of functions that take a piece of output as the input (typically a character vector), and return a character vector to be written to the output document. This may not be easy to understand for now, but hopefully you can see the idea more clearly with a small example below explaining how the output of a simple code chunk is rendered through knitr’s output hooks. Consider this code chunk with one line of code: ```{r} 1 + 1 ``` After knitr evaluates the code chunk, it gets two output elements, and both are stored as character strings: the source code &quot;1 + 1&quot;, and the text output &quot;[1] 2&quot;. These character strings will be further processed by chunk hooks for the desired output format. For example, for Markdown documents, knitr will wrap the source code in a fenced code block with a language name. This is done through the source hook, which more or less looks like this function: # for the above case, `x` is a character string &#39;1 + 1&#39; function(x, options) { # the little &#39;r&#39; here indicates the language name paste(c(&quot;```r&quot;, x, &quot;```&quot;), collapse = &quot;\\n&quot;) } Similar, the text output is processed by the output hook that looks like this function: function(x, options) { paste(c(&quot;```&quot;, x, &quot;```&quot;), collapse = &quot;\\n&quot;) } So the final output of the above code chunk is: ```r 1 + 1 ``` ``` [1] 2 ``` The actual hooks are more complicated than the two functions above, but the idea is the same. You may obtain the actual hooks from the object knit_hooks via the get() method, e.g., knitr::knit_hooks$get(&quot;source&quot;) knitr::knit_hooks$get(&quot;output&quot;) # or knitr::knit_hooks$get(c(&#39;source&#39;, &#39;output&#39;)) Unless you are truly interested in making contributions to the knitr package, we do not recommend that you read the source code of these built-in hooks, which can be found in the scripts named in the form hooks-*.R at https://github.com/yihui/knitr/tree/master/R (e.g., hooks-md.R contains hooks for R Markdown documents). As a knitr user, it usually suffices if you know how to create custom output hooks by taking advantage of the built-in hooks. You will learn that in several examples in this chapter, and we show the basic idea below. A custom output hook is registered through the set() method on knit_hooks. Because this method will override the existing default hook, we recommend that you save a copy of existing hook, process the output elements in your own way, and pass the results to the default hook. The usual syntax is: # using local() is optional here (we just want to avoid # creating unnecessary global variables like `hook_old`) local({ hook_old &lt;- knitr::knit_hooks$get(&quot;NAME&quot;) # save the old hook knitr::knit_hooks$set(NAME = function(x, options) { # now do whatever you want to do with x, and pass the # new x to the old hook hook_old(x, options) }) }) Here NAME is the name of the hook, which can be one of the following values: source: processing the source code. output: processing text output. warning: processing warnings (usually from warning()). message: processing messages (usually from message()). error: processing error messages (usually from stop()). plot: processing plot file paths. inline: processing output from inline R expressions. chunk: processing output from the whole chunk. document: processing the whole document. The meaning of the argument x in the hook functions is explained in the above list. For the options argument of a hook, it denotes the chunk options (as a list) for the current code chunk. For example, if you set foo = TRUE on a chunk, you can obtain its value via options$foo in the hook. The options argument is not available to the inline and document hooks. Output hooks give you the ultimate control over every single piece of your chunk and document output. Compared with chunk options, which often have predefined purposes, output hooks can be much more powerful since they are user-defined functions, and you can do anything you want in functions. "],
["hook-hide.html", "10.1 Redact source code", " 10.1 Redact source code Sometimes we may not want to fully display our source code in the report. For example, you may a password in a certain line of code. We mentioned in Section 9.3 that you can use the chunk option eval to select which expressions in the R code to display (e.g., show the second expression via echo = 2). In this section, we provide a more flexible method that does not require you to specify the indices of expressions. The basic idea is that you add a special comment to the code (e.g., # SECRET!!). When this comment is detected in a line of code, you omit that line. Below is a full example using the source hook: --- title: Using the `source` hook to hide certain lines of code --- First, we set up a `source` hook to exclude the lines of code that contain the string `# SECRET!!` at the end. ```{r, include=FALSE} local({ hook_source &lt;- knitr::knit_hooks$get(&#39;source&#39;) knitr::knit_hooks$set(source = function(x, options) { x &lt;- x[!grepl(&#39;# SECRET!!$&#39;, x)] hook_source(x, options) }) }) ``` Now we can test the new hook. When you knit this document, you will not see the lines with the special comment `# SECRET!!`. ```{r} 1 + 1 # normal code to be displayed # please use your real username and password auth &lt;- httr::authenticate(&quot;user&quot;, &quot;passwd&quot;) auth &lt;- httr::authenticate(&quot;yihui&quot;, &quot;horsebattery&quot;) # SECRET!! httr::GET(&quot;http://httpbin.org/basic-auth/user/passwd&quot;, auth) ``` The key part in the above source hook is this line, which matches the trailing comment # SECRET!! in the source code vector x via grepl() and exclude the matches: x &lt;- x[!grepl(&quot;# SECRET!!$&quot;, x)] Precisely speaking, the above hook will exclude whole expressions containing the trailing comment # SECRET!!, instead of individual lines, because x is actually a vector of R expressions. For example, for the code chunk below: 1 + 1 if (TRUE) { 1:10 } The value of x in the source hook is: c(&quot;1 + 1&quot;, &quot;if (TRUE) {\\n 1:10\\n}&quot;) If you want to hide lines instead of expressions of R code, you will have to split x into individual lines. You may consider using the function xfun::split_lines(). The body of the hook function will be: x &lt;- xfun::split_lines(x) # split into individual lines x &lt;- x[!grepl(&quot;# SECRET!!$&quot;, x)] x &lt;- paste(x, collapse = &quot;\\n&quot;) # combine into a single string hook_source(x, options) This example shows you how to manipulate the source code string, and grepl() is certainly not the only choice of string manipulation. In Section 10.2, we will show another example. "],
["hook-number.html", "10.2 Add line numbers to source code", " 10.2 Add line numbers to source code In this section, we show an example of defining a source hook to add line numbers as comments to the source code. For example, for this code chunk: ```{r} if (TRUE) { x &lt;- 1:10 x + 1 } ``` We want the output to be: if (TRUE) { # 1 x &lt;- 1:10 # 2 x + 1 # 3 } # 4 The full example is below: --- title: Add line numbers to source code --- We set up a `source` hook to add line numbers to the source code. The numbers appear in comments at the end of each line. ```{r, include=FALSE} local({ hook_source &lt;- knitr::knit_hooks$get(&#39;source&#39;) knitr::knit_hooks$set(source = function(x, options) { x &lt;- xfun::split_lines(x) n &lt;- nchar(x, &#39;width&#39;) i &lt;- seq_along(x) # line numbers n &lt;- n + nchar(i) s &lt;- knitr:::v_spaces(max(n) - n) x &lt;- paste(x, s, &#39; # &#39;, i, sep = &#39;&#39;, collapse = &#39;\\n&#39;) hook_source(x, options) }) }) ``` Now we can test the new hook. When you knit this document, you will see line numbers in trailing comments. ```{r} if (TRUE) { x &lt;- 1:10 x + 1 } ``` The main trick in the above example is to determine the number of spaces needed before the comment on each line, so the comments can align to the right. The number depends on the widths of each line of code. We leave it to readers to digest the code in the hook function. Note that an internal function knitr:::v_spaces() is used to generate spaces of specified lengths, e.g., knitr:::v_spaces(c(1, 3, 6, 0)) ## [1] &quot; &quot; &quot; &quot; &quot; &quot; &quot;&quot; The method introduced in Section 4.3 may be the actual way in which you want to add line numbers to source code. The syntax is cleaner, and it works both source code and text output blocks. The above source hook trick mainly aims to show you one possibility of manipulating the source code with a custom function. "],
["hook-scroll.html", "10.3 Scrollable text output", " 10.3 Scrollable text output In Section 6.4, we showed how to restrict the heights of code blocks and text output blocks via CSS. In fact, there is a simpler method with the chunk options attr.source and attr.output to add the style attribute to the fenced code blocks in the Markdown output. For example, for this code chunk with the attr.output option: ```{r, attr.output=&#39;style=&quot;max-height: 100px;&quot;&#39;} 1:300 ``` Its Markdown output will be: ```r 1:300 ``` ```{style=&quot;max-height: 100px;&quot;} ## [1] 1 2 3 4 5 6 7 8 9 10 ## [11] 11 12 13 14 15 16 17 18 19 20 ## ... ... ``` Then the text output block will be converted to HTML by Pandoc: &lt;pre style=&quot;max-height: 100px;&quot;&gt; &lt;code&gt;## [1] 1 2 3 4 5 6 7 8 9 10 ## [11] 11 12 13 14 15 16 17 18 19 20 ## ... ...&lt;/code&gt; &lt;/pre&gt; To learn more about Pandoc’s fenced code blocks, please read its manual at https://pandoc.org/MANUAL.html#fenced-code-blocks. The attr.source and attr.output options have made it possible for us to specify maximum heights for individual code chunks. However, the syntax is a little clunky, and requires a better understanding of CSS and Pandoc’s Markdown syntax. Below we show an example of a custom output hook that works with a custom chunk option max.height, so you will only need to set the chunk option like max.height = &quot;100px&quot; instead of attr.output = 'style=&quot;max-height: 100px;&quot;'. In this example, we only manipulate the options argument, but not the x argument. --- title: Scrollable code blocks output: html_document: highlight: tango --- We set up an `output` hook to add a `style` attribute to the text output when the chunk option `max.height` is set. ```{r, include=FALSE} options(width = 60) local({ hook_output &lt;- knitr::knit_hooks$get(&#39;output&#39;) knitr::knit_hooks$set(output = function(x, options) { options$attr.output &lt;- c( options$attr.output, sprintf(&#39;style=&quot;max-height: %s;&quot;&#39;, options$max.height) ) hook_output(x, options) }) }) ``` Without the `max.height` option, you will see the full output, e.g., ```{r} 1:100 ``` Now we set `max.height` to `100px`. You will see a scrollbar in the text output because its height is larger than 100px. ```{r, max.height=&#39;100px&#39;} 1:100 ``` Essentially the `max.height` option is converted to the `attr.output` option. It works even if the `attr.output` option is present, i.e., it will not override the `attr.output` option, e.g., we show line numbers on the left side of the text output via the `.numberLines` attribute: ```{r, max.height=&#39;100px&#39;, attr.output=&#39;.numberLines&#39;} 1:100 ``` Figure 10.1 shows the output. Note that in the last code chunk with the chunk option attr.output, the option will not be overridden by max.height because we respect existing attributes by combining them with the style attribute generated by max.height: options$attr.output &lt;- c( options$attr.output, sprintf(&#39;style=&quot;max-height: %s;&quot;&#39;, options$max.height) ) FIGURE 10.1: An example of scrollable text output, with its height specified in the chunk option max.height. You can use the similar trick in the source hook to limit the height of source code blocks. "],
["hook-truncate.html", "10.4 Truncate text output", " 10.4 Truncate text output When the text output from a code chunk is lengthy, you may want to only show the first few lines. For example, when printing a data frame of a few thousand rows, it may not be helpful to show the full data, and the first few lines may be enough. Below we redefine the output hook so that we can control the maximum number of lines via a custom chunk option out.lines: # save the built-in output hook hook_output &lt;- knitr::knit_hooks$get(&quot;output&quot;) # set a new output hook to truncate text output knitr::knit_hooks$set(output = function(x, options) { if (!is.null(n &lt;- options$out.lines)) { x &lt;- xfun::split_lines(x) if (length(x) &gt; n) { # truncate the output x &lt;- c(head(x, n), &quot;....\\n&quot;) } x &lt;- paste(x, collapse = &quot;\\n&quot;) } hook_output(x, options) }) The basic idea of the above hook function is that if the number of lines of the text output is greater than the threshold set in the chunk option out.lines (stored in the variable n in the function body), we only keep the first n lines and add .... to indicate the output is truncated. Now we can test the new output hook by setting the chunk option out.lines = 4 on the chunk below: print(cars) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 .... And you see four lines of output as expected. Since we have stored the original output hook in hook_output, we can restore it by calling the set() method again: knitr::knit_hooks$set(output = hook_output) As an exercise to readers, you may try to truncate the output in a different way: given the chunk option out.lines to determine the maximum number of lines, can you truncate the output in the middle instead of the end? For example, if out.lines = 10, you extract the first and last five lines, and add .... in the middle like this: ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 7 22 .... ## 46 24 70 ## 47 24 92 ## 48 24 93 ## 49 24 120 ## 50 25 85 "],
["hook-html5.html", "10.5 Output figures in the HTML5 format", " 10.5 Output figures in the HTML5 format By default, plots in R Markdown are included in the tag &lt;img src=&quot;...&quot; /&gt; in a &lt;p&gt; or &lt;div&gt; tag in the HTML output. This example below shows how to use the HTML5 &lt;figure&gt; tag to display plots. --- title: Output figures in `&lt;figure&gt;` tags output: html_document --- Given a plot file path `x` and a figure caption in the chunk option `options$fig.cap`, we want to write the plot in the HTML5 tag in this form: ```html &lt;figure&gt; &lt;img src=&quot;PATH&quot; alt=&quot;CAPTION&quot; /&gt; &lt;figcaption&gt;CAPTION&lt;/figcaption&gt; &lt;/figure&gt; ``` Now we redefine the `plot` hook (only when the output format is HTML): ```{r} if (knitr::is_html_output()) knitr::knit_hooks$set( plot = function(x, options) { cap &lt;- options$fig.cap # figure caption tags &lt;- htmltools::tags as.character(tags$figure( tags$img(src = x, alt = cap), tags$figcaption(cap) )) } ) ``` The plot from the code chunk below will be placed in the `&lt;figure&gt;` tag: ```{r, fig.cap=&#39;A scatterplot for the cars data.&#39;} par(mar = c(4.5, 4.5, .2, .2)) plot(cars, pch = 19, col = &#39;red&#39;) ``` We add some CSS styles to &quot;see&quot; the `&lt;figure&gt;` and `&lt;figcaption&gt;` tags better (the `figure` has a dashed border, and the caption has a light pink background): ```{css, echo=FALSE} figure { border: 2px dashed red; margin: 1em 0; } figcaption { padding: .5em; background: lightpink; font-size: 1.3em; font-variant: small-caps; } ``` The figure output is shown in Figure 10.2. Note that we actually overrode the default plot hook in this example, while most other examples in this chapter build custom hooks on top of the default hooks. You should completely override default hooks only when you are sure you want to ignore some built-in features of the default hooks. For example, the plot hook function in this case did not consider possible chunk options like out.width = '100%' or fig.show = 'animate'. FIGURE 10.2: A figure in the HTML5 figure tag. This example shows you what you can possibly do with the plot file path x in the plot hook. If all you need is to customize the style of figures, you do not have to use the HTML5 tags. Usually the default plot hook will output images in the HTML code like this: &lt;div class=&quot;figure&quot;&gt; &lt;img src=&quot;PATH&quot; /&gt; &lt;p class=&quot;caption&quot;&gt;CAPTION&lt;/p&gt; &lt;/div&gt; So you can just define css rules for div.figure and p.caption. "],
["chunk-hooks.html", "Chapter 11 Chunk Hooks", " Chapter 11 Chunk Hooks "],
["knitr-misc.html", "Chapter 12 Miscellaneous knitr Tricks", " Chapter 12 Miscellaneous knitr Tricks Besides chunk options, output hooks, and chunk hooks, there are other useful functions and tricks in knitr, which we will introduce in this chapter. "],
["load-cache.html", "12.1 Use an object before it is created", " 12.1 Use an object before it is created All code in a knitr document, including the code in code chunks and inline R expressions, is executed in the linear order from beginning to end. In theory, you cannot use a variable before it is assigned a value. However, in certain cases, we may want to mention the value of a variable earlier in the document. For example, it is common to present a result in the abstract of an article, but the result is actually computed later in the document. Below is an example that illustrates the idea but will not compile: --- title: An important report abstract: &gt; In this analysis, the average value of `x` is `r mx`. --- We create the object `mx` in the following chunk: ```{r} x &lt;- 1:100 mx &lt;- mean(x) ``` To solve this problem, the value of the object has to be saved somewhere and loaded the next time when the document is compiled. Please note that this means the document has to be compiled at least twice. Below is one possible solution using the saveRDS() function: ```{r, include=FALSE} mx &lt;- if (file.exists(&#39;mean.rds&#39;)) { readRDS(&#39;mean.rds&#39;) } else { &quot;The value of `mx` is not available yet&quot; } ``` --- title: An important report abstract: &gt; In this analysis, the average value of `x` is `r mx`. --- We create the object `mx` in the following chunk: ```{r} x &lt;- 1:100 mx &lt;- mean(x) saveRDS(mx, &#39;mean.rds&#39;) ``` The first time when you compile this document, you will see the phrase “The value of mx is not available yet” in the abstract. Later when you compile it again, you will see the actual value of mx. The function knitr::load_cache() is an alternative solution, which allows you to load the value of an object from a specific code chunk after the chunk has been cached. The idea is similar to the above example, but it will save you the effort of manually saving and loading an object, because the object is automatically saved to the cache database, and you only need to load it via load_cache(). Below is the simplified example: --- title: An important report abstract: &gt; In this analysis, the average value of `x` is `r knitr::load_cache(&#39;mean-x&#39;, &#39;mx&#39;)`. --- We create the object `mx` in the following chunk: ```{r mean-x, cache=TRUE} x &lt;- 1:100 mx &lt;- mean(x) ``` In this example, we added a chunk label mean-x to the R code chunk (which is passed to the load_cache() function), and cached it using the chunk option cache = TRUE. All objects in this code chunk will be saved to the cache database. Again, you will have to compile this document at least twice, so the object mx can be correctly loaded from the cache database. If the value of mx is not going to be changed in the future, you do not need to compile the document one more time. If you do not have to specify the object name in load_cache() in the second argument, the whole cache database will be loaded as a list, and you can use any objects available in the list before these objects are created later in the document, e.g., res &lt;- knitr::load_cache(&quot;mean-x&quot;) res$x # the object `x` res$mx # the obejct `mx` "],
["knit-exit.html", "12.2 Exit knitting early", " 12.2 Exit knitting early Sometimes we may want to exit knitting early and not at the end of the document. For example, we may be working on some analysis and only wish to share the first half of the results, or we may still be working on code at the bottom that is not yet complete. In these situations, we could consider using the knit_exit() function in a code chunk, which will end the knitting process after that chunk. Below is a simple example, where we have a very simple chunk followed by a more time-consuming one: ```{r} 1 + 1 knitr::knit_exit() ``` You will only see the above content in the output. ```{r} Sys.sleep(100) ``` Normally you have to wait for 100 seconds, but since we have called knit_exit(), the rest of the document will be ignored. "],
["fig-chunk.html", "12.3 Generate a plot and display it elsewhere", " 12.3 Generate a plot and display it elsewhere Normally plots generated in a code chunk are displayed beneath the code chunk, but you can choose to show them elsewhere and (optionally) hide them in the code chunk. Below is an example: We generate a plot in this code chunk but do not show it: ```{r cars-plot, dev=&#39;png&#39;, fig.show=&#39;hide&#39;} plot(cars) ``` After another paragraph, we introduce the plot: ![A nice plot.](`r knitr::fig_chunk(&#39;cars-plot&#39;, &#39;png&#39;)`) In the code chunk, we used the chunk option fig.show='hide' to hide the plot temporarily. Then in another paragraph, we called the function knitr::fig_chunk() to retrieve the path of the plot file, which is usually like test_files/figure-html/cars-plot-1.png. You need to pass the chunk label and the graphical device name to fig_chunk() for it to calculate the plot file path. You may see https://stackoverflow.com/a/46305297/559676 for an application of fig_chunk() to blogdown websites. "],
["duplicate-label.html", "12.4 Allow duplicate labels in code chunks", " 12.4 Allow duplicate labels in code chunks By default, knitr does not allow duplicate code chunk labels in the document. Duplicate labels will result in an error when the document is knitted. This occurs most frequently when a code chunk is copied and pasted within a document. You may have seen an error message like this: processing file: myfile.Rmd Error in parse_block(g[-1], g[1], params.src) : duplicate label &#39;cars&#39; Calls: &lt;Anonymous&gt; ... process_file -&gt; split_file -&gt; lapply -&gt; FUN -&gt; parse_block Execution halted However, there are scenarios where we may wish to allow duplicate labels. For example, if we have one parent document parent.Rmd in which we knit the child document multiple times, it will fail: # settings settings &lt;- list(...) # run once knit_child(&quot;useful_analysis.Rmd&quot;) # new settings settings &lt;- list(...) # run again knit_child(&quot;useful_analysis.Rmd&quot;) In this scenario, we can allow duplicate labels by setting this global option in R before the child document is knitted: options(knitr.duplicate.label = &quot;allow&quot;) You should set this option with caution. As with most error messages, they are there for a reason. Allowing duplicate chunks can create silent problems with figures and cross-references. For example, if two code chunks have the same label and both chunks generate plots, their plot files will overwrite each other (without an error or warning message), because the filenames of plots are determined by the chunk labels. "],
["tables.html", "Chapter 13 Tables", " Chapter 13 Tables Tables are one of the primary ways in which we can communicate results in a report, and you may often desire to tweak their appearance to suit your particular needs. In this chapter, we will highlight several techniques that can be used to customize tables. This chapter aims to: Show all features of the table-generating function knitr::kable(). Highlight more advanced customization of tables using the the kableExtra package. Provide examples of other packages that can be used to produce tables. "],
["kable.html", "13.1 The function knitr::kable()", " 13.1 The function knitr::kable() The kable() function in knitr is a very simple table generator, and is simple by design. It only generates tables for strictly rectangular data such as matrices and data frames. You cannot heavily format the table cells or merge cells. However, this function does have a large number of arguments for you to customize the appearance of tables: kable(x, format, digits = getOption(&quot;digits&quot;), row.names = NA, col.names = NA, align, caption = NULL, label = NULL, format.args = list(), escape = TRUE, ...) 13.1.1 Possible table formats In most cases, knitr::kable(x) may be enough if you only need a simple table for the data object x. The format argument is automatically set according to the knitr source document format. Its possible values are latex, html, markdown, pandoc, and rst. For R Markdown documents, kable() uses the pandoc format for tables by default, which looks like this: knitr::kable(head(mtcars[, 1:4]), &quot;pandoc&quot;) mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 Datsun 710 22.8 4 108 93 Hornet 4 Drive 21.4 6 258 110 Hornet Sportabout 18.7 8 360 175 Valiant 18.1 6 225 105 You can also generate tables in Markdown, HTML, LaTeX, reStructuredText: knitr::kable(head(mtcars[, 1:4]), &quot;markdown&quot;) | | mpg| cyl| disp| hp| |:-----------------|----:|---:|----:|---:| |Mazda RX4 | 21.0| 6| 160| 110| |Mazda RX4 Wag | 21.0| 6| 160| 110| |Datsun 710 | 22.8| 4| 108| 93| |Hornet 4 Drive | 21.4| 6| 258| 110| |Hornet Sportabout | 18.7| 8| 360| 175| |Valiant | 18.1| 6| 225| 105| knitr::kable(mtcars[1:2, 1:2], &quot;html&quot;) &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style=&quot;text-align:left;&quot;&gt; &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; mpg &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; cyl &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 Wag &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; knitr::kable(head(mtcars[, 1:4]), &quot;latex&quot;) \\begin{tabular}{l|r|r|r|r} \\hline &amp; mpg &amp; cyl &amp; disp &amp; hp\\\\ \\hline Mazda RX4 &amp; 21.0 &amp; 6 &amp; 160 &amp; 110\\\\ \\hline Mazda RX4 Wag &amp; 21.0 &amp; 6 &amp; 160 &amp; 110\\\\ \\hline Datsun 710 &amp; 22.8 &amp; 4 &amp; 108 &amp; 93\\\\ \\hline Hornet 4 Drive &amp; 21.4 &amp; 6 &amp; 258 &amp; 110\\\\ \\hline Hornet Sportabout &amp; 18.7 &amp; 8 &amp; 360 &amp; 175\\\\ \\hline Valiant &amp; 18.1 &amp; 6 &amp; 225 &amp; 105\\\\ \\hline \\end{tabular} knitr::kable(head(mtcars[, 1:4]), &quot;rst&quot;) ================= ==== === ==== === \\ mpg cyl disp hp ================= ==== === ==== === Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 Datsun 710 22.8 4 108 93 Hornet 4 Drive 21.4 6 258 110 Hornet Sportabout 18.7 8 360 175 Valiant 18.1 6 225 105 ================= ==== === ==== === Please note that only the formats pandoc and markdown are portable, i.e., they work for any output document formats. Other table formats only work for specific output formats, e.g., format = 'latex' only works for LaTeX output documents. Using a specific table format will give you more control, at the price of sacrificing portability. If you only need one table format that is not the default format for a document, you can set the global R option knitr.table.format, e.g., options(knitr.table.format = &quot;latex&quot;) This option can also be a function that returns the format string or NULL. In the case of NULL, knitr will try to automatically decide the appropriate format. For example, we can use the latex format only when the output format is LaTeX: options(knitr.table.format = function() { if (knitr::is_latex_output()) &quot;latex&quot; else &quot;pandoc&quot; }) 13.1.2 Change column names The names of columns in a data frame may not be the same as what we want to display to readers. In R, the column names of data often do not use spaces to separate words but dots or underscores instead, which may not feel natural when we read them in a table. We can use the the col.names argument to replace the column names with a vector of new names. For example, we substitute the dots with spaces in the column names of the iris data: iris2 &lt;- head(iris) knitr::kable(iris2, col.names = gsub(&quot;[.]&quot;, &quot; &quot;, names(iris))) Sepal Length Sepal Width Petal Length Petal Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 13.1.3 Specify column alignment To change the alignment of the table columns, you can use either a vector of values consisting of characters l (left), c (center), and r (right) or a single multi-character string for alignment, so kable(..., align = c('c', 'l')) can be shortened to kable(..., align = 'cl'). By default, numeric columns are right-aligned, and other columns are left-aligned. Here is an example: knitr::kable(iris2, align = &quot;lccrr&quot;) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 13.1.4 Add a table caption You can add a caption to the table via the caption argument, e.g. (see Table 13.1 for the output), knitr::kable(iris2, caption = &quot;An example table caption.&quot;) TABLE 13.1: An example table caption. Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa As we mentioned in Section 3.3, a table can be cross-referenced when it has a caption and the output format is from bookdown. 13.1.5 Format numeric columns You can set the maximum number of decimal places via the digits argument (which will be passed to the round() function), and other formatting arguments via format.args (to be passed to the format() function in base R). First we show a few simple examples of round() and format() so you will understand how the arguments work later in kable(): round(1.234567, 0) ## [1] 1 round(1.234567, digits = 1) ## [1] 1.2 round(1.234567, digits = 3) ## [1] 1.235 format(1000, scientific = TRUE) ## [1] &quot;1e+03&quot; format(10000.123, big.mark = &quot;,&quot;) ## [1] &quot;10,000&quot; Then we round and format numbers in a table: d &lt;- cbind(X1 = runif(3), X2 = 10^c(3, 5, 7), X3 = rnorm(3, 0, 1000)) # at most 4 decimal places knitr::kable(d, digits = 4) X1 X2 X3 0.3539 1e+03 -1542.5533 0.2397 1e+05 723.3763 0.5100 1e+07 -571.9407 # round columns separately knitr::kable(d, digits = c(5, 0, 2)) X1 X2 X3 0.35389 1e+03 -1542.55 0.23970 1e+05 723.38 0.50996 1e+07 -571.94 # do not use the scientific notation knitr::kable(d, digits = 3, format.args = list(scientific = FALSE)) X1 X2 X3 0.354 1000 -1542.553 0.240 100000 723.376 0.510 10000000 -571.941 # add commas to big numbers knitr::kable(d, digits = 3, format.args = list(big.mark = &quot;,&quot;, scientific = FALSE)) X1 X2 X3 0.354 1,000 -1,542.553 0.240 100,000 723.376 0.510 10,000,000 -571.941 13.1.6 Display missing values By default, missing values (i.e., NA) are displayed as the character string NA in the table. You can replace it with other values or choose not to display anything (i.e., leave the NA cells empty) with the global R option knitr.kable.NA, e.g., we make NA cells empty in the second table and display ** in the third table below: d[rbind(c(1, 1), c(2, 3), c(3, 2))] &lt;- NA knitr::kable(d) # NA is displayed by default X1 X2 X3 NA 1e+03 -1542.6 0.2397 1e+05 NA 0.5100 NA -571.9 # replace NA with empty strings opts &lt;- options(knitr.kable.NA = &quot;&quot;) knitr::kable(d) X1 X2 X3 1e+03 -1542.6 0.2397 1e+05 0.5100 -571.9 options(knitr.kable.NA = &quot;**&quot;) knitr::kable(d) X1 X2 X3 ** 1e+03 -1542.6 0.2397 1e+05 ** 0.5100 ** -571.9 options(opts) # restore global R options 13.1.7 Escape special characters If you are familiar with HTML or LaTeX, you know that there are a few special characters in these languages. To generate safe output, kable() will escape these special characters by default via the argument escape = TRUE, which means all characters will be generated verbatim, and special characters lose their special meanings. For example, &gt; will be substituted with &amp;gt; for HTML tables, and _ will be escaped as \\_ for LaTeX tables. If you are an expert and know how to use special characters properly, you may disable this argument via escape = FALSE. In the second table below, we include a few LaTeX math expressions that contain special characters $, \\, and _: m &lt;- lm(dist ~ speed, data = cars) d &lt;- coef(summary(m)) knitr::kable(d) Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -17.579 6.7584 -2.601 0.0123 speed 3.932 0.4155 9.464 0.0000 # add a few math expressions to row and column names rownames(d) &lt;- c(&quot;$\\\\beta_0$&quot;, &quot;$\\\\beta_1$&quot;) colnames(d)[4] &lt;- &quot;$P(T &gt; |t|)$&quot; knitr::kable(d, escape = FALSE) Estimate Std. Error t value \\(P(T &gt; |t|)\\) \\(\\beta_0\\) -17.579 6.7584 -2.601 0.0123 \\(\\beta_1\\) 3.932 0.4155 9.464 0.0000 Without escape = FALSE, special characters will be either escaped or substituted. For example, $ is escaped as \\$, _ is escaped as \\_, and \\ is substituted with \\textbackslash{}: knitr::kable(d, format = &quot;latex&quot;, escape = TRUE) \\begin{tabular}{l|r|r|r|r} \\hline &amp; Estimate &amp; Std. Error &amp; t value &amp; \\$P(T &gt; |t|)\\$\\\\ \\hline \\$\\textbackslash{}beta\\_0\\$ &amp; -17.579 &amp; 6.7584 &amp; -2.601 &amp; 0.0123\\\\ \\hline \\$\\textbackslash{}beta\\_1\\$ &amp; 3.932 &amp; 0.4155 &amp; 9.464 &amp; 0.0000\\\\ \\hline \\end{tabular} Other common special LaTeX characters include #, %, &amp;, {, and }. Common special HTML characters include &amp;, &lt;, &gt;, and &quot;. You need to be cautious when generating tables with escape = FALSE, and make sure you are using the special characters in the right way. It is a very common mistake to use escape = FALSE and include % or _ in column names or the caption of a LaTeX table without realizing that they are special. If you are not sure how to properly escape special characters, there are two internal helper functions in knitr. Below are some examples: knitr:::escape_latex(c(&quot;100%&quot;, &quot;# a comment&quot;, &quot;column_name&quot;)) ## [1] &quot;100\\\\%&quot; &quot;\\\\# a comment&quot; &quot;column\\\\_name&quot; knitr:::escape_html(c(&quot;&lt;attention&gt;&quot;, &quot;x = \\&quot;character\\&quot;&quot;, &quot;a &amp; b&quot;)) ## [1] &quot;&amp;lt;attention&amp;gt;&quot; ## [2] &quot;x = &amp;quot;character&amp;quot;&quot; ## [3] &quot;a &amp;amp; b&quot; 13.1.8 Multiple tables side by side You can pass a list of data frames or matrices to kable() to generate multiple tables side by side. For example, Table 13.2 contains two tables generated from the code below: knitr::kable( list( head(cars, 3), head(mtcars[, 1:3], 5) ), caption = &#39;Two tables placed side by side.&#39;, booktabs = TRUE, valign = &#39;t&#39; ) TABLE 13.2: Two tables placed side by side. speed dist 4 2 4 10 7 4 mpg cyl disp Mazda RX4 21.0 6 160 Mazda RX4 Wag 21.0 6 160 Datsun 710 22.8 4 108 Hornet 4 Drive 21.4 6 258 Hornet Sportabout 18.7 8 360 Please note that this feature only works for HTML and PDF output. 13.1.9 Generate multiple tables from a for-loop One common confusion about kable() is that it does not work inside for-loops. This problem is not specific to kable() but exists in many other packages, too. The reason is a little complicated. In case you are interested in the technicality, it has been explained in the blog post “The Ghost Printer Behind Top-level R Expressions”. You may expect the following code chunk to generate three tables, but it will not: ```{r} for (i in 1:3) { knitr::kable(head(iris)) } ``` You have to explicitly print the kable() results, and apply the chunk option results = 'asis', e.g., ```{r, results=&#39;asis&#39;} for (i in 1:3) { print(knitr::kable(head(iris))) } ``` In general, when you generate output from a for-loop, we recommend that you add a few linebreaks (\\n) or an HTML comment (&lt;!-- --&gt;) after each output element to clearly separate all output elements, e.g., ```{r, results=&#39;asis&#39;} for (i in 1:3) { print(knitr::kable(head(iris), caption = &#39;A caption.&#39;)) cat(&#39;\\n\\n&lt;!-- --&gt;\\n\\n&#39;) } ``` Without the separators, Pandoc may be fail to detect the individual elements. For example, when a plot is followed immediately by a table, the table will not be recognized: ![](logo.png) mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 But it will be if there is a clear separation like (note that we added an empty line below the image): ![](logo.png) mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 or ![](logo.png) &lt;!-- --&gt; mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 13.1.10 Customize LaTeX tables If the only output format you need is LaTeX, there are a few extra options you can use in kable(). Note that these options will be ignored in other types of output such as HTML. Unless you have set the table format option globally (see Section 13.1.1), you will have to use the format argument of kable() explicitly in the examples of this section, e.g., knitr::kable(iris2, format = &quot;latex&quot;, booktabs = TRUE) When you assign a caption to a table (see Section 13.1.4), kable() will use the table environment to include the table, i.e., \\begin{table} % the table body (usually the tabular environment) \\end{table} You can change this environment via the table.envir argument, e.g., knitr::kable(cars[1:2, ], format = &quot;latex&quot;, table.envir = &quot;figure&quot;) \\begin{figure} \\begin{tabular}{r|r} \\hline speed &amp; dist\\\\ \\hline 4 &amp; 2\\\\ \\hline 4 &amp; 10\\\\ \\hline \\end{tabular} \\end{figure} The floating position of the table is controlled by the argument position. For example, we can try to force a table to float to the bottom of a page via position = &quot;!b&quot;: knitr::kable(cars[1:2, ], format = &quot;latex&quot;, table.envir = &quot;table&quot;, position = &quot;!b&quot;) \\begin{table}[!b] \\begin{tabular}{r|r} \\hline speed &amp; dist\\\\ \\hline 4 &amp; 2\\\\ \\hline 4 &amp; 10\\\\ \\hline \\end{tabular} \\end{table} When a table has a caption, you can also assign a short caption to it via the caption.short argument, e.g., knitr::kable(iris2, caption = &quot;A long long long caption!&quot;, caption.short = &quot;A short one.&quot;) The short caption goes into the square brackets of the \\caption[]{} command in LaTeX, and is often used in the List of Tables of the PDF output document (if the short caption is not provided, the full caption is displayed there). If you are familiar with the LaTeX package booktabs for publication quality tables, you can set booktabs = TRUE, e.g., iris3 &lt;- head(iris, 10) knitr::kable(iris3, format = &quot;latex&quot;, booktabs = TRUE) \\begin{tabular}{rrrrl} \\toprule Sepal.Length &amp; Sepal.Width &amp; Petal.Length &amp; Petal.Width &amp; Species\\\\ \\midrule 5.1 &amp; 3.5 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.9 &amp; 3.0 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.7 &amp; 3.2 &amp; 1.3 &amp; 0.2 &amp; setosa\\\\ 4.6 &amp; 3.1 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 5.0 &amp; 3.6 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ \\addlinespace 5.4 &amp; 3.9 &amp; 1.7 &amp; 0.4 &amp; setosa\\\\ 4.6 &amp; 3.4 &amp; 1.4 &amp; 0.3 &amp; setosa\\\\ 5.0 &amp; 3.4 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 4.4 &amp; 2.9 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.9 &amp; 3.1 &amp; 1.5 &amp; 0.1 &amp; setosa\\\\ \\bottomrule \\end{tabular} Please note that when you need additional LaTeX packages such as booktabs for an R Markdown document, you have to declare these packages in YAML (see Section 5.3 for how). Depending on whether the argument booktabs is TRUE or FALSE (default), the table appearance is different. For booktabs = FALSE: Table columns are separated by vertical lines. You can explicitly remove the vertical lines via the vline argument, e.g., knitr::kable(iris, vline = &quot;&quot;) (the default is vline = &quot;|&quot;). You can set this option as a global R option so you do not need to set it for every single table, e.g., options(knitr.table.vline = &quot;&quot;). The horizontal lines can be defined via arguments toprule, midrule, linesep, and bottomrule. Their default values are all \\hline. For booktabs = TRUE: There are no vertical lines in the table, but you can add these lines via the vline argument. The table only has horizontal lines for the table header and the bottom row. The default argument values are toprule = &quot;\\\\toprule&quot;, midrule = &quot;\\\\midrule&quot;, and bottomrule = &quot;\\\\bottomrule&quot;. A line space is added to every five rows by default. This is controlled by the argument linesep, which defaults to c(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;\\\\addlinespace&quot;). If you want to add a space to every three rows, you can do this: knitr::kable(iris3, format = &quot;latex&quot;, linesep = c(&quot;&quot;, &quot;&quot;, &quot;\\\\addlinespace&quot;), booktabs = TRUE) \\begin{tabular}{rrrrl} \\toprule Sepal.Length &amp; Sepal.Width &amp; Petal.Length &amp; Petal.Width &amp; Species\\\\ \\midrule 5.1 &amp; 3.5 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.9 &amp; 3.0 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.7 &amp; 3.2 &amp; 1.3 &amp; 0.2 &amp; setosa\\\\ \\addlinespace 4.6 &amp; 3.1 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 5.0 &amp; 3.6 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 5.4 &amp; 3.9 &amp; 1.7 &amp; 0.4 &amp; setosa\\\\ \\addlinespace 4.6 &amp; 3.4 &amp; 1.4 &amp; 0.3 &amp; setosa\\\\ 5.0 &amp; 3.4 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 4.4 &amp; 2.9 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ \\addlinespace 4.9 &amp; 3.1 &amp; 1.5 &amp; 0.1 &amp; setosa\\\\ \\bottomrule \\end{tabular} Sometimes your table may be longer than a page. In this case, you can use the argument longtable = TRUE, which uses the LaTeX package longtable to span your table to multiple pages. Tables are center-aligned by default when they are included in a table environment (i.e., when the table has a caption). If you do not want to center a table, use the argument centering = FALSE. 13.1.11 Customize HTML tables If you want to customize tables generated via knitr::kable(format = &quot;html&quot;), there is only one extra argument table.attr besides the common arguments mentioned in previous sections. The argument table.attr allows you to add arbitrary attributes to the &lt;table&gt; tag. For example: knitr::kable(mtcars[1:2, 1:2], table.attr = &quot;class=\\&quot;striped\\&quot;&quot;, format = &quot;html&quot;) &lt;table class=&quot;striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style=&quot;text-align:left;&quot;&gt; &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; mpg &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; cyl &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 Wag &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; We added a class striped to the table. However, a class name is not enough to change the appearance of a table. You have to define CSS rules for the class. For example, to make a striped table that has different colors for odd and even rows, you can add a lightgray background to even or odd rows: .striped tr:nth-child(even) { background: #eee; } The above CSS rule means all rows (i.e., the &lt;tr&gt; tags) with even row numbers (:nth-child(even)) that are children of an element with the striped class will have a background color #eee. A little bit CSS can make a plain HTML table look decent. Figure 13.1 is a screenshot of an HTML table to which the following CSS rules are applied: table { margin: auto; border-top: 1px solid #666; border-bottom: 1px solid #666; } table thead th { border-bottom: 1px solid #ddd; } th, td { padding: 5px; } thead, tfoot, tr:nth-child(even) { background: #eee; } FIGURE 13.1: A striped table created with HTML and CSS. "],
["kableextra.html", "13.2 kableExtra", " 13.2 kableExtra The kableExtra package (Zhu 2019) is designed to extend the basic functionality of tables produced using kable. As explained by the package author, the intention with using kableExtra is that you can: Use default base kable() for all simple tables Use kable() with kableExtra to generate 90 % of complex/advanced/self-customized/beautiful tables in either HTML or LaTeX Only have to mess with raw HTML/LaTeX in the last 10% cases where kableExtra cannot solve the problem This section aims to provide a quick overview of some of the main principles of kableExtra, and provides some examples of how you may wish to integrate it into your document. For extensive documentation, readers are recommended to check the documentation online, which provides full details on how the outputs can be customized for both HTML and LaTeX outputs. 13.2.1 Setup kableExtra is available to download through CRAN: # Install from CRAN install.packages(&quot;kableExtra&quot;) # install the development version devtools::install_github(&quot;haozhu233/kableExtra&quot;) 13.2.2 Customizing HTML Width and position column and row spec bootstrap styling Scroll box 13.2.3 Customizing PDF Width and position column and row spec Styling Landscape page You can scale the width of the table using the function kable_styling(latex_options = &quot;scale_down&quot;). This will force the table to the width of the page. kable(iris[1:5, ], format = &quot;latex&quot;, booktabs = TRUE) %&gt;% kable_styling(latex_options = &quot;scale_down&quot;) References "],
["table-ext.html", "13.3 Extension packages", " 13.3 Extension packages Although kable offers flexible tables within R Markdown documents, you may wish to extend the functionality of tables using other packages. There are several packages which have been developed to create tables in R Markdown: stargazer (Hlavac 2018) gt (Iannone, Cheng, and Schloerke 2020) flextable (Gohel 2019) These packages are explained in the following subsections. 13.3.1 stargazer TO ADD 13.3.2 gt TO ADD 13.3.3 flextable This package is developed by David Gohel and is part of the officer package suits. flextable aims at easily creating tables for reporting to be embedded within: R Markdown documents with support for HTML, Word and PowerPoint documents. Microsoft Word or PowerPoint documents directly. References "],
["other-languages.html", "Chapter 14 Other Languages ", " Chapter 14 Other Languages "],
["eng-cat.html", "14.1 Write the chunk content to a file via the cat engine", " 14.1 Write the chunk content to a file via the cat engine Sometimes it could be useful to write to some files from inside the Rmd. If this could be achieved using pure R code in a r code chunk, knitr as a little unknown gem for this : the cat engine. 14.1.1 About the cat engine The cat engine allows to write to a file some codes from a Rmarkdown chunk. The file path is passed as an argument in the generic engine.opts chunk options: engine.opts = list(file = &lt;file to write to&gt;). The element in this list will be pass to base::cat() function allowing to customize how the content is written to file. In this example, we will write to a temp file with fs::path_temp(). ```{cat, engine.opts = list(file = fs::path_temp(&#39;script.R&#39;))} my_function &lt;- function(x){ x+1 } ``` The content can be used by filling a chunk from that file. This is another trick made possible using the code chunk option. You’ll see the content of the file ```{r, code = readLines(fs::path_temp(&#39;script.R&#39;))} ``` This will render my_function &lt;- function(x) { x + 1 } As the code above is executed, the function is available in any following r chunk. my_function(5) rm(my_function) ## [1] 6 And the file can be sourced as usual too. source(fs::path_temp(&quot;script.R&quot;)) my_function(5) rm(my_function) ## [1] 6 Writing to an R script is not really a real use case example and the cat engine can handle any format. Here, we use it to write some yaml to a file. The default behavior for cat engine is to show nothing in the output document. However, here we will also show the content in the output R Markdown file. The cat engine understand the field lang in engine.opts option or directly class.source chunk option for html outputs (see Section 6.3). You can provide any language supported by the syntax highlighting. These two chunks are equivalent: ```{cat, engine.opts = list(file = fs::path_temp(&#39;demo.yml&#39;), lang = &quot;yaml&quot;)} a: aa: something bb: 1 b: aa: somethingelse bb: 2 ``` ```{cat, engine.opts = list(file = fs::path_temp(&#39;demo.yml&#39;)), class.source = &quot;yaml&quot;} a: aa: something bb: 1 b: aa: somethingelse bb: 2 ``` They will write to file and print the code with the chosen syntax highlighting, here yaml a: aa: something bb: 1 b: aa: somethingelse bb: 2 As previously, the file can be accessed later on and read into R yaml::read_yaml(fs::path_temp(&quot;demo.yml&quot;)) ## $a ## $a$aa ## [1] &quot;something&quot; ## ## $a$bb ## [1] 1 ## ## ## $b ## $b$aa ## [1] &quot;somethingelse&quot; ## ## $b$bb ## [1] 2 14.1.2 Generate a template file from inside the rmarkdown As detailed in section 6.3, css chunk can directly be used to apply custom style. However, it is also possible to provide a custom css file to pandoc directly to be used with the html output and the cat engine can be used to write this css file from the Rmarkdown. One important key is that all chunks are executed before pandoc conversion. This means it is possible in the yaml header to link to a file that does not exist and will be created when rendering the document. This complete example shows how to generate my_custom.css from a chunk in the document while telling pandoc to use this css with the yaml field css: my_custom.css --- title: &quot;CSS generated in chunk&quot; output: html_document: css: my_custom.css --- The chunk below will be written to `my_custom.css` that will be used during pandoc conversion, as specified in the yaml header above. ```{cat, engine.opts = list(file = &quot;my_custom.css&quot;)} h2 { color: blue; } ``` ## And this title will blue. This could also be used to generate any file that can be given to pandoc, like an in_header tex file for a pdf_document output.3 --- title: &quot;Generate a header template for latex from a chunk&quot; author: &quot;Jane Doe&quot; output: pdf_document: includes: in_header: header.tex --- # how it works Adding some content to put in header file. ```{cat, engine.opts=list(file = &#39;header.tex&#39;)} \\usepackage{fancyhdr} \\usepackage{lipsum} \\pagestyle{fancy} \\fancyhead[CO,CE]{This is fancy header} \\fancyfoot[CO,CE]{And this is a fancy footer} \\fancyfoot[LE,RO]{\\thepage} \\fancypagestyle{plain}{\\pagestyle{fancy}} ``` However, the aim here is to add the author name from the yaml header into the tex template. Some R code can&#39;t be passed into the `cat` engine because it won&#39;t be executed, but it is possible to append some more to the created file. Here we generate the line to append in a R chunk using `knitr::knit_expand` templating tool. Any other way to build a string will work obviously. ```{r, include = FALSE} author_template &lt;- knitr::knit_expand( text = &#39;\\\\fancyfoot[CO,CE]{%rmarkdown::metadata$author%}&#39;, delim = c(&quot;%&quot;, &quot;%&quot;)) ``` Then, providing `append = TRUE` and using the `code` chunk option to provide content to the chunk ```{cat, engine.opts=list(file = &#39;header.tex&#39;, append = TRUE), code = author_template} ``` This will generate a footer with the author name that we got from the yaml header. Pretty advanced combination ! # Some other content to see the footer \\lipsum[1-30] "],
["managing-projects.html", "Chapter 15 Managing Projects", " Chapter 15 Managing Projects When you work on larger projects or reports, you may not want to put all text and code in a single R Markdown document, but organize them in smaller units instead. In this chapter, we introduce tips on how to organize multiple files related to R Markdown. "],
["source-script.html", "15.1 Source external R scripts", " 15.1 Source external R scripts If your R Markdown document has a large amount of code, you may consider putting some code in external R scripts, and run these scripts via source() or sys.source(), e.g., ```{r, include=FALSE} source(&quot;your-script.R&quot;, envir = knitr::knit_global()) # or sys.source(&quot;your-script.R&quot;, envir = knitr::knit_global()) ``` Next in the R Markdown document, you can use objects created in these scripts (e.g., data objects or functions). This way will not only make your R Markdown document cleaner, but also make it more convenient for you to develop R code (e.g., debugging R code is often easier with pure R scripts than R Markdown). Note that we used include = FALSE in the above example because we only want to execute the script without showing any output. If you do want output, you may remove this chunk option, or use the options in Section 9.3 to selectively hide or show different types of output. "],
["option-code.html", "15.2 Read external scripts into a chunk", " 15.2 Read external scripts into a chunk There is a disadvantage of the source() method in Section 15.1. That is, you will not be able to see the source code by default. You can use source(..., echo = TRUE), but the source code will not be properly syntax highlighted. In this section, we introduce an alternative method that does not have this drawback. Basically, when you have one or more external scripts, you may read them and pass the content to the code option of a chunk. The code option can take a character vector and treat it as the content of the code chunk. Below we show a few examples: The `code` option can take a character vector of source code. For example: ```{r, code=c(&#39;1 + 1&#39;, &#39;if (TRUE) plot(cars)&#39;)} ``` You can also read an external file: ```{r, code=readLines(&#39;your-script.R&#39;)} ``` You can read as many scripts as you want: ```{r, include=FALSE} read_files &lt;- function(files) { unlist(lapply(files, readLines)) } ``` ```{r, code=read_files(c(&#39;one.R&#39;, &#39;two.R&#39;))} ``` You can read scripts of other languages, too. See Chapter ?? for how to use other languages in R Markdown. Here are a few more examples on non-R code: Read a Python script: ```{python, code=readLines(&#39;script.py&#39;)} ``` Read a C++ file: ```{Rcpp, code=readLines(&#39;file.cpp&#39;)} ``` With the code option, you can develop complicated code in your favorite editor, and read it into a code chunk of an R Markdown document. "],
["read-chunk.html", "15.3 Read multiple code chunks from an external script", " 15.3 Read multiple code chunks from an external script In Section 15.2, we introduced a way to read code into a single code chunk. In this section, we introduce one method to read multiple code chunks from an external script. The key is that you need to label the code in the script, and you can use the same labels in the code chunks in your R Markdown document, so the code in the external script can be mapped to the code chunks via the function knitr::read_chunk(). To label a block of code in a script, you write the label after ## ---- (optionally, you can add a series of dashes to the end of this line). One script can contain multiple labeled code blocks, e.g., ## ---- test-a -------- 1 + 1 ## ---- test-b -------- if (TRUE) { plot(cars) } We assume that the filename of the above script is test.R. In the R Markdown document, we can read it via knitr::read_chunk(), and use the code in code chunks with the labels, e.g., Read an external script: ```{r, include=FALSE, cache=FALSE} knitr::read_chunk(&#39;test.R&#39;) ``` Now we can use the code, e.g., ```{r, test-a, echo=FALSE} ``` ```{r, test-b, fig.height=4} ``` Note that we use knitr::read_chunk() mainly for its side-effect, so please make sure the code chunk in which we call this function is not cached (see Section 9.1 for the explanation). Like methods introduced in Section 15.1 and Section 15.2, this method also gives you the flexibility of developing code in a separate environment. "],
["package-vignette.html", "15.4 R package vignettes", " 15.4 R package vignettes If you have experience in developing R packages, or your project requires clear documentation and rigorous tests for custom functions written in the project, you may consider organizing the project as an R package. If you do not know how to create an R package, you can easily get started in the RStudio IDE by clicking the menu File -&gt; New Project, and selecting the project type to be an R package. There are a lot of benefits of using an R package to manage a project. For example, you can place datasets in the data/ folder, write R code under R/, generate documentation (e.g., using roxygen2) to man/, and add unit tests to test/. When it comes to the R Markdown reports, you can write them as package vignettes under vignettes/. In the vignettes, you can load datasets and call functions in the package. When you build the package (via the command R CMD build or RStudio), vignettes will be automatically compiled. To create a package vignette in R Markdown, the easiest way is through the RStudio menu File -&gt; New File -&gt; R Markdown -&gt; From Template (see Figure 15.1). Then you select “Package Vignette” from the rmarkdown package, and you will get a vignette template. After changing the title, author, and other metadata of the template, you can start writing the content of your report. FIGURE 15.1: Create a package vignette in RStudio. If you do not use RStudio, below is what the YAML frontmatter typically looks like: --- title: &quot;Vignette Title&quot; author: &quot;Vignette Author&quot; output: rmarkdown::html_vignette vignette: &gt; %\\VignetteIndexEntry{Vignette Title} %\\VignetteEngine{knitr::rmarkdown} %\\VignetteEncoding{UTF-8} --- Note that you need to change the vignette title in both the title field and the \\VignetteIndexEntry{} command. Besides the above information in the vignette, you also need to do two more things in your package DESCRIPTION file: Specify VignetteBuilder: knitr in the DESCRIPTION file. Add Suggests: knitr, rmarkdown in DESCRIPTION. The vignette output format does not have to be HTML. It can also be PDF, so you can use output: pdf_document, too. Any other output formats that create HTML or PDF are also okay, such as beamer_presentation and tufte::tufte_html. However, currently R only recognizes HTML and PDF vignettes. "],
["child-document.html", "15.5 Child documents", " 15.5 Child documents When you feel an R Markdown document is too long, you may consider splitting it into shorter documents, and include them as child documents of the main document via the chunk option child. The child option takes a character vector of paths to the child documents, e.g., ```{r, child=c(&#39;one.Rmd&#39;, &#39;two.Rmd&#39;)} ``` Since knitr chunk options can take values from arbitrary R expressions, one application of the child option is the conditional inclusion of a document. For example, if your report has an appendix containing technical details that your boss may not be interested in, you may use a variable to control whether this appendix is included in the report: Change `BOSS_MODE` to `TRUE` if this report is to be read by the boss: ```{r, include=FALSE} BOSS_MODE &lt;- FALSE ``` Conditionally include the appendix: ```{r, child=if (!BOSS_MODE) &#39;appendix.Rmd&#39;} ``` Or if you are writing a news report on a football game that has not taken place yet, you may include different child documents depending on the outcome, e.g., child = if (winner == 'brazil') 'brazil.Rmd' else 'germany.Rmd'. Then as soon as the game (between Germany and Brazil) is finished, you can publish your report. Another way to compile child documents is the function knitr::knit_child(). You can call this function in an R code chunk or an inline R expression, e.g., ```{r, echo=FALSE, results=&#39;asis&#39;} res &lt;- knitr::knit_child(&#39;child.Rmd&#39;, quiet = TRUE) cat(res, sep = &#39;\\n&#39;) ``` The function knit_child() returns a character vector of the knitted output, which we can write back to the main document with cat() and the chunk option results = 'asis'. You can even use a child document as a template, and call knit_child() on it repeatedly with different parameters. In the example below, we run a regression using mpg as the response variable and each of the rest of variables in the mtcars data as the explanatory variable. ```{r, echo=FALSE, results=&#39;asis&#39;} res &lt;- lapply(names(mtcars)[-1], function(x) { knitr::knit_child(text = c( &#39;## Regression on &quot;`r x`&quot;&#39;, &#39;&#39;, &#39;```{r}&#39;, &#39;lm(mpg ~ ., data = mtcars[, c(&quot;mpg&quot;, x)])&#39;, &#39;```&#39;, &#39;&#39; ), envir = environment(), quiet = TRUE) }) cat(unlist(res), sep = &#39;\\n&#39;) ``` To make the above example self-contained, we used the text argument of knit_child() instead of a file input to pass the R Markdown content to be knitted. You can certainly write the content to a file, and pass a path to knit_child() instead. For example, you can save the content below to a file named template.Rmd: ## Regression on &quot;`r x`&quot; ```{r} lm(mpg ~ ., data = mtcars[, c(&quot;mpg&quot;, x)]) ``` And knit the file instead: res &lt;- lapply(names(mtcars)[-1], function(x) { knitr::knit_child( &#39;template.Rmd&#39;, envir = environment(), quiet = TRUE ) }) cat(unlist(res), sep = &#39;\\n&#39;) "],
["bookdown.html", "15.6 Using bookdown", " 15.6 Using bookdown The bookdown package (Xie 2020a) is designed for creating long-form documents with multiple R Markdown documents. For example, if you want to write a book, you can put each chapter in its own Rmd file. For RStudio users, the easiest way to get started is to create a bookdown project from File -&gt; New Project -&gt; New Directory -&gt; Book Project using bookdown, as you can see from Figure 15.2. FIGURE 15.2: Create a bookdown project in RStudio. To demonstrate the usage, we provide a minimal example consisting of three files within the same directory: directory |- index.Rmd |- 01-intro.Rmd |- 02-analysis.Rmd Below we show the content of each file and explain their roles. index.Rmd: --- title: &quot;A Minimal bookdown Project&quot; site: bookdown::bookdown_site output: bookdown::gitbook --- # Preface {-} Some content The first file is typically called index.Rmd. It should be the only Rmd file in which you provide the YAML frontmatter. It should also include a special YAML field site: bookdown::bookdown_site, so that rmarkdown knows to use bookdown to build all Rmd files, instead of rendering a single Rmd file. You can use any bookdown output formats, such as bookdown::gitbook, bookdown::pdf_book, bookdown::word_document2, and bookdown::epub_book. The next two Rmd files are two chapters: 01-intro.Rmd: # Chapter 1 This is chapter 1. 02-analysis.Rmd: # Chapter 2 This is chapter 2. To render these Rmd files, you should call bookdown::render_book('index.Rmd') instead of rmarkdown::render(). Under the hood, bookdown merges all Rmd files into a single Rmd by default and compile it. Files are merged in the alphabetical order. That is why we added numeric prefixes to filenames in the above example. There are a lot of settings that you can customize for a bookdown project. For a more comprehensive overview of bookdown, you may see Chapter 18 the rmarkdown book (Xie, Allaire, and Grolemund 2018). For the full documentation, see the bookdown book (Xie 2016). References "],
["workflow.html", "Chapter 16 Workflow", " Chapter 16 Workflow In this chapter, we introduce some tips on working with individual R Markdown documents as well as running your R Markdown projects. "],
["rstudio-shortcuts.html", "16.1 RStudio keyboard shortcuts", " 16.1 RStudio keyboard shortcuts The R Markdown format can be used with any editor of your choice, as long as R, the rmarkdown package, and Pandoc are installed. However, RStudio has a deep integration with R Markdown so you can work with R Markdown smoothly. Like any IDE, RStudio has keyboard shortcuts. A full list can be found under the menu Tools -&gt; Keyboard Shortcuts Help. Some of the most useful shortcuts related to R Markdown are summarized in Table 16.1. TABLE 16.1: RStudio keyboard shortcuts related to R Markdown. Task Windows &amp; Linux macOS Insert R chunk Ctrl+Alt+I Command+Option+I Preview HTML Ctrl+Shift+K Command+Shift+K Knitr document (knitr) Ctrl+Shift+K Command+Shift+K Compile Notebook Ctrl+Shift+K Command+Shift+K Compile PDF Ctrl+Shift+K Command+Shift+K Run all chunks above Ctrl+Alt+P Command+Option+P Run current chunk Ctrl+Alt+C Command+Option+C Run current chunk Ctrl+Shift+Enter Command+Shift+Enter Run next chunk Ctrl+Alt+N Command+Option+N Run all chunks Ctrl+Alt+R Command+Option+R Go to next chunk/title Ctrl+PgDown Command+PgDown Go to previous chunk/title Ctrl+PgUp Command+PgUp Show/hide document outline Ctrl+Shift+O Command+Shift+O Build book, website, … Ctrl+Shift+B Command+Shift+B Besides, you can press F7 to spellcheck your document. You can also restart the R session by Ctrl + Alt + F10 (or Command + Option + F10 on macOS), which can be helpful for reproducibility, because results are more likely to be reproducible if they are computed from a new R session. This can also be done through the dropdown menu “Restart R and Run All Chunks” behind the “Run” button on the toolbar. "],
["rmarkdown-render.html", "16.2 Render R Markdown with rmarkdown::render()", " 16.2 Render R Markdown with rmarkdown::render() If you do not use RStudio or any other IDEs, you need to know this fact: R Markdown documents are rendered through the function rmarkdown::render(). This means you can programmatically render an R Markdown document in any R script. For example, you could render a series of reports in a for-loop for each state of a coutry: for (state in state.name) { rmarkdown::render( &#39;input.Rmd&#39;, output_file = paste0(state, &#39;.html&#39;) ) } The output filename will be different for each state. You can also make use of the state variable in the document input.Rmd, e.g., --- title: &quot;A report for `r state`&quot; output: html_document --- The area of `r state` is `r state.area[state.name == state]` square miles. You may read the help page ?rmarkdown::render to know other possible arguments. Here we just want to mention two of them, i.e., the clean and envir arguments. The former (clean) is particularly helpful for debugging when anything goes wrong with the Pandoc conversion. If you call rmarkdown::render(..., clean = FALSE), all intermediate files will be preserved, including the intermediate .md file knitted from the .Rmd file. If Pandoc signals an error, you may start debugging from this .md file. The latter (envir) offers a way to render a document with the guarantee of an empty new environment when you call rmarkdown::render(..., envir = new.env()). "],
["parameterized-reports.html", "16.3 Parameterized reports", " 16.3 Parameterized reports In Section 16.2, we mentioned one way to render a series of reports in a for-loop. In fact, rmarkdown::render() has an argument named params specifically designed for this task. You can parameterize your report through this argument. When you specify parameters for a report, you can use the variable params in your report. For example, if you call: for (state in state.name) { rmarkdown::render(&#39;input.Rmd&#39;, params = list(state = state)) } Then in input.Rmd, the object params will be a list that contains the state variable: --- title: &quot;A report for `r params$state`&quot; output: html_document --- The area of `r params$state` is `r state.area[state.name == params$state]` square miles. Another way to specify parameters for a report is to use the YAML field params, e.g., --- title: Parameterized reports output: html_document params: state: Nebraska year: 2019 midwest: true --- Note that you can include as many parameters in the params YAML field or the params argument of rmarkdown::render(). If both the YAML field and the argument are present, the parameter values in the argument will override the corresponding parameters in YAML. For example, when we call rmarkdown::render(..., params = list(state = 'Iowa', year = 2018) on the previous example that has the params field, params$state will become Iowa (instead of Nebraska) and params$year will become 2018 (instead of 2019) in the R Markdown document. When rendering the same R Markdown document to a series of reports, you need to adjust the output_file argument of rmarkdown::render(), to make sure each report has its unique filename, so you will not accidentally override certain report files. For example, you can write a function to generate a report for each state and each year: render_one &lt;- function(state, year) { # assuming the output format of input.Rmd is PDF rmarkdown::render( &#39;input.Rmd&#39;, output_file = paste0(state, &#39;-&#39;, year, &#39;.pdf&#39;), params = list(state = state, year = year) ) } Then you can use nested for-loops to generate all reports: for (state in state.name) { for (year in 2000:2020) { render_one(state, year) } } At the end, you will get a series of report files like Alabama-2000.pdf, Alabama-2001.pdf, …, Wyoming-2019.pdf, and Wyoming-2020.pdf. For parameterized reports, you can also input parameters interactively through a graphical user interface (GUI) created from Shiny. This requires you to provide a params field in YAML, and rmarkdown will automatically create the GUI using the appropriate input widgets for each parameter (e.g., a checkbox will be provided for a boolean parameter). To start the GUI, you can call rmarkdown::render() with params = 'ask' if you do not use RStudio: rmarkdown::render(&quot;input.Rmd&quot;, params = &quot;ask&quot;) If you use RStudio, you can click the menu Knit with Parameters behind the Knit button. Figure 16.1 shows an example GUI for parameters. FIGURE 16.1: Knit an R Markdown document with parameters that you can input from a GUI. For more information on parameterized reports, you may read Chapter 15 of the R Markdown book (Xie, Allaire, and Grolemund 2018). References "],
["custom-knit.html", "16.4 Customize the Knit button", " 16.4 Customize the Knit button When you click the Knit button in RStudio, it will call the rmarkdown::render() function in a new R session and output a file of the same base name as the input file in the same directory. For example, knitting example.Rmd with the output format html_document will create an output file example.html. There may be situations in which we want to customize how the document is rendered. For example, perhaps we would like the rendered document to contain the current date, or would like to output the compiled report into a different directory. Although we can achieve these goals by calling rmarkdown::render() (see Section 16.2) with the appropriate output_file argument, it can be inconvenient to have to rely on a custom call to `rmarkdown::render() to compile your report. It is possible to control the behavior of the Knit button by providing the knit field within the YAML frontmatter of your document. The field takes a function with the arguments inputFile and encoding. You can either write the source code of the function directly in the knit field, or put the function elsewhere (e.g., in an R package) and call the function in the knit field. If you routinely need the custom knit function, we would recommend that you put it in a package, instead of repeating its source code in every single R Markdown document. If you store the code directly within YAML, you must wrap the entire function in parentheses. If the source code has multiple lines, you have to indent all lines (except the first line) by at least two spaces. For example, if we want the output filename to include the date on which it is rendered, we could use the following YAML code: --- knit: (function(inputFile, encoding) { rmarkdown::render(input = inputFile, encoding = encoding, output_file = paste0( xfun::sans_ext(inputFile), &#39;-&#39;, Sys.Date(), &#39;.html&#39; ) ) }) --- For example, if we knit example.Rmd on 2019-07-29, the output filename will be example-2019-07-29.html. While the above approach looks simple and straightforward enough, embedding a function directly in your YAML may make it difficult for you to maintain it, unless the function is only to be used once with a single R Markdown document. In general, we would recommend using an R package to maintain such a function, e.g., you may create a function knit_with_date() in a package: #&#39; Custom Knit function for RStudio #&#39; #&#39; @export knit_with_date &lt;- function(inputFile, encoding) { rmarkdown::render( inputFile, encoding = encoding, output_file = paste0( xfun::sans_ext(inputFile), &#39;-&#39;, Sys.Date(), &#39;.&#39;, xfun::file_ext(inputFile) ) ) } If you add the above code to a package named myPackage, you will be able to refer to your custom knit function using the following YAML setting: --- knit: myPackage::knit_with_date --- You may refer to the help page ?rmarkdown::render to find out more ideas on how you could customize your knit function behind the Knit button in RStudio. "],
["diagrams.html", "Chapter 17 Diagrams", " Chapter 17 Diagrams It is often useful to express analysis using flowcharts and diagrams within reports. Although there are many separate programs which can be used to produce these, it can be beneficial to create these within our analysis directly. This makes it easier to update and edit the graph if we need to edit it in the future, and allows us to use the results from our analysis directly within the diagrams, making them more information. While there are several different packages available for R, we will focus on the package DiagrammeR (Iannone 2020). We also recommend that you read at http://rich-iannone.github.io/DiagrammeR/index.html . In this chapter we will explain some of the basic usages of the package. References "],
["basic-diagrams.html", "17.1 Basic diagrams", " 17.1 Basic diagrams DiagrammeR provides methods to build graphs for a number of different graphing languages. R Studio provides native support for Graphviz (.gv) and mermaid (.mmd) files. Using files of these types in RStudio provides the advantage of syntax coloring and allowing a quick preview of the diagram. For example, we can make a simple flowchart with the following code: DiagrammeR::grViz(&quot;digraph { graph [layout = dot, rankdir = LR] node [shape = rectangle] rec1 [label = &#39;Step 1&#39;] rec2 [label = &#39;Step 2&#39;] rec3 [label = &#39;Step 3&#39;] rec4 [label = &#39;Step 4&#39;] # edge definitions with the node IDs rec1 -&gt; rec2 -&gt; rec3 -&gt; rec4 }&quot;, height = 200) FIGURE 17.1: A basic graphic using DiagrammeR There are extensive controls which can be used to control the shape of nodes, colours, line types and add additional parameters. "],
["adding-parameters-to-plots.html", "17.2 Adding parameters to plots", " 17.2 Adding parameters to plots Graphviz substitution allows for mixing in R expressions into a Graphviz graph specification without sacrificing readability. If you specify a subsitution with @@, you must ensure there is a valid expression for that substitution. The expressions are placed as footnotes and their evaluations must result in an R vector object (i.e., not a data frame, list, or matrix). Because there is the possibility to have multiple substitutions, numbering is required. Thus, the @@ notation is immediately followed by a number and that number should correspond to the number of the footnoted R expression. For example, suppose we have a dataset which is being analysed, and we would like to identify how many values are removed at each stage of a process. DiagrammeR::grViz(&quot; digraph graph2 { graph [layout = dot, rankdir = LR] # node definitions with substituted label text node [shape = rectangle] a [label = &#39;@@1&#39;] b [label = &#39;@@2&#39;] c [label = &#39;@@3&#39;] d [label = &#39;@@4&#39;] a -&gt; b -&gt; c -&gt; d } [1]: paste(&#39;Input Data&#39;, 1) [2]: paste(&#39;Step &#39;, 1) [3]: paste(&#39;Step &#39;, 1) [4]: paste(&#39;Step &#39;, 1) &quot;) "],
["references.html", "References", " References "]
]
